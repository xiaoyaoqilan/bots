"""
ç½‘æ ¼äº¤æ˜“ç³»ç»Ÿåè°ƒå™¨

æ ¸å¿ƒåè°ƒé€»è¾‘ï¼š
1. åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ
2. å¤„ç†è®¢å•æˆäº¤äº‹ä»¶
3. è‡ªåŠ¨æŒ‚åå‘è®¢å•
4. å¼‚å¸¸å¤„ç†å’Œæš‚åœæ¢å¤
"""

import asyncio
import time
from typing import Any, Dict, List, Optional
from decimal import Decimal
from datetime import datetime

from ....logging import get_logger
from ..interfaces import IGridStrategy, IGridEngine, IPositionTracker
from ..models import (
    GridConfig, GridState, GridOrder, GridOrderSide,
    GridOrderStatus, GridStatus, GridStatistics
)
from ..scalping import ScalpingManager
from ..capital_protection import CapitalProtectionManager
from ..take_profit import TakeProfitManager
from ..price_lock import PriceLockManager


class GridCoordinator:
    """
    ç½‘æ ¼äº¤æ˜“ç³»ç»Ÿåè°ƒå™¨

    èŒè´£ï¼š
    1. æ•´åˆç­–ç•¥ã€å¼•æ“ã€è·Ÿè¸ªå™¨
    2. è®¢å•æˆäº¤åçš„åå‘æŒ‚å•é€»è¾‘
    3. æ‰¹é‡æˆäº¤å¤„ç†
    4. ç³»ç»ŸçŠ¶æ€ç®¡ç†
    5. å¼‚å¸¸å¤„ç†
    """

    def __init__(
        self,
        config: GridConfig,
        strategy: IGridStrategy,
        engine: IGridEngine,
        tracker: IPositionTracker,
        grid_state: GridState
    ):
        """
        åˆå§‹åŒ–åè°ƒå™¨

        Args:
            config: ç½‘æ ¼é…ç½®
            strategy: ç½‘æ ¼ç­–ç•¥
            engine: æ‰§è¡Œå¼•æ“
            tracker: æŒä»“è·Ÿè¸ªå™¨
            grid_state: ç½‘æ ¼çŠ¶æ€ï¼ˆå…±äº«å®ä¾‹ï¼‰
        """
        self.logger = get_logger(__name__)
        self.config = config
        self.strategy = strategy
        self.engine = engine
        self.tracker = tracker

        # ğŸ”¥ è®¾ç½® engine çš„ coordinator å¼•ç”¨ï¼ˆç”¨äº health_checker è®¿é—®å‰¥å¤´çš®ç®¡ç†å™¨ç­‰ï¼‰
        if hasattr(engine, 'coordinator'):
            engine.coordinator = self

        # ç½‘æ ¼çŠ¶æ€ï¼ˆä½¿ç”¨ä¼ å…¥çš„å…±äº«å®ä¾‹ï¼‰
        self.state = grid_state

        # è¿è¡Œæ§åˆ¶
        self._running = False
        self._paused = False
        self._resetting = False  # ğŸ”¥ é‡ç½®è¿›è¡Œä¸­æ ‡å¿—ï¼ˆæœ¬é‡‘ä¿æŠ¤ã€å‰¥å¤´çš®é‡ç½®ç­‰ï¼‰

        # å¼‚å¸¸è®¡æ•°
        self._error_count = 0
        self._max_errors = 5  # æœ€å¤§é”™è¯¯æ¬¡æ•°ï¼Œè¶…è¿‡åˆ™æš‚åœ

        # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨
        self._price_escape_start_time: Optional[float] = None  # ä»·æ ¼è„±ç¦»å¼€å§‹æ—¶é—´
        self._last_escape_check_time: float = 0  # ä¸Šæ¬¡æ£€æŸ¥æ—¶é—´
        self._escape_check_interval: int = 10  # æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
        self._is_resetting: bool = False  # æ˜¯å¦æ­£åœ¨é‡ç½®ç½‘æ ¼

        # ğŸ”¥ å‰¥å¤´çš®ç®¡ç†å™¨
        self.scalping_manager: Optional[ScalpingManager] = None
        self._scalping_position_monitor_task: Optional[asyncio.Task] = None
        self._scalping_position_check_interval: int = 1  # å‰¥å¤´çš®æ¨¡å¼æŒä»“æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼ŒRESTè½®è¯¢ï¼‰
        self._last_ws_position_size = Decimal('0')  # ç”¨äºWebSocketäº‹ä»¶é©±åŠ¨
        self._last_ws_position_price = Decimal('0')
        # ğŸ”¥ æŒä»“ç›‘æ§çŠ¶æ€ï¼ˆç±»ä¼¼è®¢å•ç»Ÿè®¡çš„æ··åˆæ¨¡å¼ï¼‰
        self._position_ws_enabled: bool = False  # WebSocketæŒä»“ç›‘æ§æ˜¯å¦å¯ç”¨
        self._last_position_ws_time: float = 0  # æœ€åä¸€æ¬¡æ”¶åˆ°WebSocketæŒä»“æ›´æ–°çš„æ—¶é—´
        self._last_order_filled_time: float = 0  # æœ€åä¸€æ¬¡è®¢å•æˆäº¤çš„æ—¶é—´ï¼ˆç”¨äºåˆ¤æ–­WSæ˜¯å¦å¤±æ•ˆï¼‰
        self._position_ws_response_timeout: int = 5  # è®¢å•æˆäº¤åWebSocketå“åº”è¶…æ—¶ï¼ˆç§’ï¼‰
        self._position_ws_check_interval: int = 5  # å°è¯•æ¢å¤WebSocketçš„é—´éš”ï¼ˆç§’ï¼‰
        self._last_position_ws_check_time: float = 0  # ä¸Šæ¬¡æ£€æŸ¥WebSocketçš„æ—¶é—´
        # ğŸ”¥ å®šæœŸRESTæ ¡éªŒï¼ˆå¿ƒè·³æ£€æµ‹ï¼‰
        self._position_rest_verify_interval: int = 60  # æ¯åˆ†é’Ÿç”¨RESTæ ¡éªŒWebSocketæŒä»“ï¼ˆç§’ï¼‰
        self._last_position_rest_verify_time: float = 0  # ä¸Šæ¬¡RESTæ ¡éªŒçš„æ—¶é—´
        if config.is_scalping_enabled():
            self.scalping_manager = ScalpingManager(config)
            self.logger.info("âœ… å‰¥å¤´çš®ç®¡ç†å™¨å·²å¯ç”¨")

        # ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤ç®¡ç†å™¨
        self.capital_protection_manager: Optional[CapitalProtectionManager] = None
        if config.is_capital_protection_enabled():
            self.capital_protection_manager = CapitalProtectionManager(config)
            self.logger.info("âœ… æœ¬é‡‘ä¿æŠ¤ç®¡ç†å™¨å·²å¯ç”¨")

        # ğŸ’° æ­¢ç›ˆç®¡ç†å™¨
        self.take_profit_manager: Optional[TakeProfitManager] = None
        if config.take_profit_enabled:
            self.take_profit_manager = TakeProfitManager(config)
            self.logger.info("âœ… æ­¢ç›ˆç®¡ç†å™¨å·²å¯ç”¨")

        # ğŸ”’ ä»·æ ¼é”å®šç®¡ç†å™¨
        self.price_lock_manager: Optional[PriceLockManager] = None
        if config.price_lock_enabled:
            self.price_lock_manager = PriceLockManager(config)
            self.logger.info("âœ… ä»·æ ¼é”å®šç®¡ç†å™¨å·²å¯ç”¨")

        # ğŸ’° è´¦æˆ·ä½™é¢è½®è¯¢ï¼ˆBackpackç»Ÿä¸€è´¦æˆ·ï¼‰
        self._balance_monitor_task: Optional[asyncio.Task] = None
        self._balance_update_interval: int = 10  # ä½™é¢æ›´æ–°é—´éš”ï¼ˆç§’ï¼Œç”¨æˆ·è‡ªå®šä¹‰ï¼‰
        self._spot_balance: Decimal = Decimal('0')  # ç°è´§ä½™é¢ï¼ˆæœªç”¨ä½œä¿è¯é‡‘ï¼‰
        self._collateral_balance: Decimal = Decimal('0')  # æŠµæŠ¼å“ä½™é¢ï¼ˆç”¨ä½œä¿è¯é‡‘ï¼‰
        self._order_locked_balance: Decimal = Decimal('0')  # è®¢å•å†»ç»“ä½™é¢
        self._last_balance_update: Optional[datetime] = None

        self.logger.info(f"ç½‘æ ¼åè°ƒå™¨åˆå§‹åŒ–: {config}")

    async def initialize(self):
        """åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ"""
        try:
            self.logger.info("å¼€å§‹åˆå§‹åŒ–ç½‘æ ¼ç³»ç»Ÿ...")

            # 1. å…ˆåˆå§‹åŒ–æ‰§è¡Œå¼•æ“ï¼ˆè®¾ç½® engine.configï¼‰
            await self.engine.initialize(self.config)
            self.logger.info("æ‰§è¡Œå¼•æ“åˆå§‹åŒ–å®Œæˆ")

            # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šè·å–å½“å‰ä»·æ ¼å¹¶è®¾ç½®ä»·æ ¼åŒºé—´
            if self.config.is_follow_mode():
                current_price = await self.engine.get_current_price()
                self.config.update_price_range_for_follow_mode(current_price)
                self.logger.info(
                    f"ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ ¹æ®å½“å‰ä»·æ ¼ ${current_price:,.2f} è®¾ç½®ä»·æ ¼åŒºé—´ "
                    f"[${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                )

            # 2. åˆå§‹åŒ–ç½‘æ ¼çŠ¶æ€
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )
            self.logger.info(f"ç½‘æ ¼çŠ¶æ€åˆå§‹åŒ–å®Œæˆï¼Œå…±{self.config.grid_count}ä¸ªç½‘æ ¼å±‚çº§")

            # 3. åˆå§‹åŒ–ç­–ç•¥ï¼Œç”Ÿæˆæ‰€æœ‰åˆå§‹è®¢å•
            initial_orders = self.strategy.initialize(self.config)

            # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šä»·æ ¼åŒºé—´åœ¨åˆå§‹åŒ–åæ‰è®¾ç½®
            if self.config.is_follow_mode():
                self.logger.info(
                    f"ç­–ç•¥åˆå§‹åŒ–å®Œæˆï¼Œç”Ÿæˆ{len(initial_orders)}ä¸ªåˆå§‹è®¢å•ï¼Œ"
                    f"è¦†ç›–ä»·æ ¼åŒºé—´ [${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                )
            else:
                self.logger.info(
                    f"ç­–ç•¥åˆå§‹åŒ–å®Œæˆï¼Œç”Ÿæˆ{len(initial_orders)}ä¸ªåˆå§‹è®¢å•ï¼Œ"
                    f"è¦†ç›–ä»·æ ¼åŒºé—´ ${self.config.lower_price:,.2f} - ${self.config.upper_price:,.2f}"
                )

            # 4. è®¢é˜…è®¢å•æ›´æ–°
            self.engine.subscribe_order_updates(self._on_order_filled)
            self.logger.info("è®¢å•æ›´æ–°è®¢é˜…å®Œæˆ")

            # ğŸ”„ 4.5. è®¢é˜…WebSocketæŒä»“æ›´æ–°ï¼ˆå®æ—¶åŒæ­¥æŒä»“ï¼‰
            # ğŸš€ ç­–ç•¥ï¼šWebSocketä¼˜å…ˆï¼ŒRESTå¤‡ç”¨ï¼ŒWebSocketé‡è¿
            self._position_ws_enabled = False  # WebSocketæŒä»“è®¢é˜…çŠ¶æ€
            self._position_sync_task = None    # æŒä»“åŒæ­¥ä»»åŠ¡

            # ğŸ” è¯Šæ–­ï¼šæ£€æŸ¥WebSocketæŒä»“ç¼“å­˜çŠ¶æ€
            if hasattr(self.engine.exchange, '_position_cache'):
                cache_status = self.engine.exchange._position_cache
                self.logger.info(
                    f"ğŸ“Š WebSocketæŒä»“ç¼“å­˜çŠ¶æ€: {len(cache_status)} ä¸ªäº¤æ˜“å¯¹")
                if self.config.symbol in cache_status:
                    cached_pos = cache_status[self.config.symbol]
                    self.logger.info(
                        f"   {self.config.symbol}: æ•°é‡={cached_pos.get('size')}, "
                        f"æˆæœ¬=${cached_pos.get('entry_price')}, "
                        f"ç¼“å­˜æ—¶é—´={cached_pos.get('timestamp')}"
                    )
                else:
                    self.logger.info(
                        f"   {self.config.symbol}: æš‚æ— ç¼“å­˜æ•°æ®ï¼ˆç­‰å¾…WebSocketæ¨é€ï¼‰")
            else:
                self.logger.warning("âš ï¸ WebSocketæŒä»“ç¼“å­˜ä¸å­˜åœ¨")

            try:
                self.logger.info("ğŸ”„ è®¢é˜…WebSocketæŒä»“æ›´æ–°æµ...")

                # è®¢é˜…WebSocketæŒä»“å›è°ƒ
                if hasattr(self.engine.exchange, 'subscribe_position_updates'):
                    await self.engine.exchange.subscribe_position_updates(
                        self.config.symbol,
                        self._on_position_update
                    )
                    self._position_ws_enabled = True
                    self.logger.info("âœ… WebSocketæŒä»“æ›´æ–°æµè®¢é˜…æˆåŠŸ")
                    self.logger.info("ğŸ“¡ ä½¿ç”¨WebSocketå®æ—¶ç›‘æ§æŒä»“å˜åŒ–")
                else:
                    self.logger.warning("âš ï¸ äº¤æ˜“æ‰€ä¸æ”¯æŒWebSocketæŒä»“è®¢é˜…")

            except Exception as e:
                self.logger.warning(f"âš ï¸ WebSocketæŒä»“è®¢é˜…å¤±è´¥: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
                self._position_ws_enabled = False

            # ğŸ”„ æ— è®ºWebSocketæ˜¯å¦æˆåŠŸï¼Œéƒ½å…ˆç”¨REST APIåŒæ­¥åˆå§‹æŒä»“
            try:
                self.logger.info("ğŸ“Š æ­£åœ¨åŒæ­¥åˆå§‹æŒä»“æ•°æ®ï¼ˆREST APIï¼‰...")
                positions = await self.engine.exchange.get_positions([self.config.symbol])
                if positions:
                    position = positions[0]
                    position_qty = position.size if position.side.value.lower() == 'long' else - \
                        position.size
                    self.tracker.sync_initial_position(
                        position=position_qty,
                        entry_price=position.entry_price
                    )
                    self.logger.info(
                        f"âœ… åˆå§‹æŒä»“åŒæ­¥å®Œæˆï¼ˆRESTï¼‰: {position.side.value} {position.size} @ ${position.entry_price}"
                    )
                else:
                    self.logger.info("ğŸ“Š REST APIæ˜¾ç¤ºæ— æŒä»“")
            except Exception as rest_error:
                self.logger.warning(f"âš ï¸ REST APIåˆå§‹æŒä»“åŒæ­¥å¤±è´¥: {rest_error}")

            # ğŸ”¥ æå‰è®¾ç½®_runningæ ‡å¿—ï¼Œç¡®ä¿ç›‘æ§ä»»åŠ¡èƒ½æ­£å¸¸è¿è¡Œ
            self._running = True

            # ğŸ”„ å¯åŠ¨æŒä»“åŒæ­¥ç›‘æ§ä»»åŠ¡ï¼ˆRESTå¤‡ç”¨ + WebSocketé‡è¿ï¼‰
            self._position_sync_task = asyncio.create_task(
                self._position_sync_monitor())
            self.logger.info("âœ… æŒä»“åŒæ­¥ç›‘æ§å·²å¯åŠ¨ï¼ˆWebSocketä¼˜å…ˆï¼ŒRESTå¤‡ç”¨ï¼Œè‡ªåŠ¨é‡è¿ï¼‰")

            # 5. æ‰¹é‡ä¸‹æ‰€æœ‰åˆå§‹è®¢å•ï¼ˆå…³é”®ä¿®æ”¹ï¼‰
            self.logger.info(f"å¼€å§‹æ‰¹é‡æŒ‚å•ï¼Œå…±{len(initial_orders)}ä¸ªè®¢å•...")
            placed_orders = await self.engine.place_batch_orders(initial_orders)

            # 6. æ‰¹é‡æ·»åŠ åˆ°çŠ¶æ€è¿½è¸ªï¼ˆåªæ·»åŠ æœªæˆäº¤çš„è®¢å•ï¼‰
            self.logger.info(f"å¼€å§‹æ·»åŠ {len(placed_orders)}ä¸ªè®¢å•åˆ°çŠ¶æ€è¿½è¸ª...")
            added_count = 0
            skipped_count = 0
            for order in placed_orders:
                # ğŸ”¥ æ£€æŸ¥è®¢å•æ˜¯å¦å·²ç»åœ¨çŠ¶æ€ä¸­ï¼ˆå¯èƒ½å·²ç»é€šè¿‡WebSocketæˆäº¤å›è°ƒå¤„ç†ï¼‰
                if order.order_id in self.state.active_orders:
                    skipped_count += 1
                    self.logger.debug(
                        f"â­ï¸ è·³è¿‡å·²å­˜åœ¨è®¢å•: {order.order_id} (Grid {order.grid_id}, {order.side.value})"
                    )
                    continue

                # ğŸ”¥ æ£€æŸ¥è®¢å•æ˜¯å¦å·²ç»æˆäº¤ï¼ˆçŠ¶æ€ä¸ºFILLEDï¼‰
                if order.status == GridOrderStatus.FILLED:
                    skipped_count += 1
                    self.logger.debug(
                        f"â­ï¸ è·³è¿‡å·²æˆäº¤è®¢å•: {order.order_id} (Grid {order.grid_id}, {order.side.value})"
                    )
                    continue

                self.state.add_order(order)
                added_count += 1
                self.logger.debug(
                    f"âœ… å·²æ·»åŠ è®¢å•åˆ°çŠ¶æ€: {order.order_id} (Grid {order.grid_id}, {order.side.value})")

            self.logger.info(
                f"âœ… æˆåŠŸæŒ‚å‡º{len(placed_orders)}/{len(initial_orders)}ä¸ªè®¢å•ï¼Œ"
                f"è¦†ç›–æ•´ä¸ªä»·æ ¼åŒºé—´"
            )
            self.logger.info(
                f"ğŸ“Š è®¢å•æ·»åŠ ç»Ÿè®¡: æ–°å¢={added_count}, è·³è¿‡={skipped_count} "
                f"(å·²å­˜åœ¨æˆ–å·²æˆäº¤)"
            )
            self.logger.info(
                f"ğŸ“Š çŠ¶æ€ç»Ÿè®¡: "
                f"ä¹°å•={self.state.pending_buy_orders}, "
                f"å–å•={self.state.pending_sell_orders}, "
                f"æ´»è·ƒè®¢å•={len(self.state.active_orders)}"
            )

            # 7. å¯åŠ¨ç³»ç»Ÿ
            self.state.start()
            # self._running = True  # å·²åœ¨å¯åŠ¨ç›‘æ§ä»»åŠ¡å‰è®¾ç½®

            self.logger.info("âœ… ç½‘æ ¼ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œæ‰€æœ‰è®¢å•å·²å°±ä½ï¼Œç­‰å¾…æˆäº¤")

        except Exception as e:
            self.logger.error(f"âŒ ç½‘æ ¼ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {e}")
            self.state.set_error()
            raise

    async def _on_position_update(self, position_info: Dict[str, Any]):
        """
        WebSocketæŒä»“æ›´æ–°å›è°ƒ - å®æ—¶åŒæ­¥æŒä»“åˆ°è¿½è¸ªå™¨

        Args:
            position_info: æŒä»“ä¿¡æ¯å­—å…¸
                - symbol: äº¤æ˜“å¯¹
                - size: æŒä»“æ•°é‡ï¼ˆå¸¦ç¬¦å·ï¼Œæ­£æ•°=å¤šä»“ï¼Œè´Ÿæ•°=ç©ºä»“ï¼‰
                - entry_price: å…¥åœºä»·æ ¼
                - unrealized_pnl: æœªå®ç°ç›ˆäº
                - side: æŒä»“æ–¹å‘
        """
        try:
            symbol = position_info.get('symbol')
            if symbol != self.config.symbol:
                return  # ä¸æ˜¯å½“å‰äº¤æ˜“å¯¹çš„æŒä»“

            position_size = position_info.get('size', 0)
            entry_price = position_info.get('entry_price', 0)
            side = position_info.get('side', 'Unknown')

            # åŒæ­¥æŒä»“åˆ°è¿½è¸ªå™¨
            self.tracker.sync_initial_position(
                position=position_size,
                entry_price=entry_price
            )

            # ğŸ”¥ æ›´æ–°WebSocketæœ€åæ¥æ”¶æ—¶é—´ï¼ˆç”¨äºå¥åº·æ£€æŸ¥ï¼‰
            self._last_position_ws_time = time.time()

            # ğŸ”¥ æ›´æ–°WebSocketæŒä»“è®°å½•ï¼ˆç”¨äºRESTæ ¡éªŒå¯¹æ¯”ï¼‰
            self._last_ws_position_size = position_size
            self._last_ws_position_price = entry_price

            # ğŸ”¥ æ ‡è®°WebSocketæŒä»“ç›‘æ§ä¸ºå¯ç”¨çŠ¶æ€
            if not self._position_ws_enabled:
                self._position_ws_enabled = True
                self.logger.info("âœ… WebSocketæŒä»“ç›‘æ§å·²å¯ç”¨ï¼ˆæ”¶åˆ°é¦–æ¬¡æŒä»“æ›´æ–°ï¼‰")

            # ğŸ”¥ ä½¿ç”¨INFOçº§åˆ«ï¼Œç¡®ä¿ç”¨æˆ·èƒ½çœ‹åˆ°æŒä»“æ›´æ–°
            self.logger.info(
                f"ğŸ“Š WebSocketæŒä»“åŒæ­¥: {symbol} {side} "
                f"æ•°é‡={position_size}, æˆæœ¬=${entry_price}"
            )

        except Exception as e:
            self.logger.error(f"âŒ å¤„ç†WebSocketæŒä»“æ›´æ–°å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())

    async def _position_sync_monitor(self):
        """
        æŒä»“åŒæ­¥ç›‘æ§ä»»åŠ¡

        åŠŸèƒ½ï¼š
        1. ç›‘æ§WebSocketæŒä»“æ›´æ–°æ˜¯å¦æ­£å¸¸
        2. å¦‚æœWebSocketå¤±è´¥ï¼Œä½¿ç”¨REST APIä½œä¸ºå¤‡ç”¨
        3. å®šæœŸå°è¯•é‡è¿WebSocket
        4. ä¸€æ—¦WebSocketæ¢å¤ï¼Œåˆ‡æ¢å›WebSocket
        """
        # åˆå§‹åŒ–æ—¶é—´æˆ³
        self._last_position_ws_time = time.time()  # WebSocketæœ€åæ¥æ”¶æŒä»“æ•°æ®çš„æ—¶é—´
        self._last_position_rest_sync = 0  # REST APIæœ€ååŒæ­¥çš„æ—¶é—´
        last_rest_log_time = 0  # RESTå¤‡ç”¨æ¨¡å¼æœ€åæ‰“å°æ—¥å¿—çš„æ—¶é—´

        # é…ç½®å‚æ•°ï¼ˆå‚è€ƒè®¢å•ç»Ÿè®¡çš„æ··åˆæ¨¡å¼ï¼‰
        rest_sync_interval = self._scalping_position_check_interval  # RESTå¤‡ç”¨åŒæ­¥é—´éš”ï¼ˆ1ç§’ï¼Œç¡®ä¿å®æ—¶æ€§ï¼‰
        ws_reconnect_interval = self._position_ws_check_interval  # WebSocketé‡è¿å°è¯•é—´éš”ï¼ˆ5ç§’ï¼‰
        monitor_check_interval = 1  # ç›‘æ§æ£€æŸ¥é—´éš”ï¼ˆ1ç§’ï¼Œä¸RESTåŒæ­¥é¢‘ç‡ä¸€è‡´ï¼‰
        rest_log_interval = 60  # RESTå¤‡ç”¨æ¨¡å¼æ—¥å¿—æ‰“å°é—´éš”ï¼ˆ60ç§’/1åˆ†é’Ÿï¼Œé¿å…åˆ·å±ï¼‰

        self.logger.info(
            f"ğŸ”„ æŒä»“åŒæ­¥ç›‘æ§å·²å¯åŠ¨: "
            f"WSå“åº”è¶…æ—¶={self._position_ws_response_timeout}ç§’, "
            f"RESTæ ¡éªŒé—´éš”={self._position_rest_verify_interval}ç§’, "
            f"RESTå¤‡ç”¨è½®è¯¢={rest_sync_interval}ç§’, "
            f"WSé‡è¿é—´éš”={ws_reconnect_interval}ç§’"
        )

        last_ws_reconnect_attempt = 0

        while self._running:
            try:
                await asyncio.sleep(monitor_check_interval)

                current_time = time.time()

                # ğŸ” æ£€æŸ¥WebSocketå¥åº·çŠ¶æ€ï¼ˆæ™ºèƒ½åˆ¤æ–­ï¼‰
                if self._position_ws_enabled:
                    ws_should_fail = False

                    # ğŸ”¥ æ¡ä»¶1ï¼šè®¢å•æˆäº¤äº†ï¼Œä½†WebSocketæ²¡æœ‰å“åº”
                    if self._last_order_filled_time > 0:
                        order_ws_delay = current_time - self._last_order_filled_time
                        ws_response_delay = self._last_order_filled_time - self._last_position_ws_time

                        # å¦‚æœè®¢å•æˆäº¤åè¶…è¿‡Nç§’ï¼ŒWebSocketè¿˜æ²¡æ¨é€æŒä»“æ›´æ–°
                        if order_ws_delay > self._position_ws_response_timeout and ws_response_delay > 0:
                            self.logger.warning(
                                f"âš ï¸ WebSocketå¤±æ•ˆ: è®¢å•æˆäº¤{order_ws_delay:.1f}ç§’åä»æ— æŒä»“æ›´æ–°ï¼Œ"
                                f"åˆ‡æ¢åˆ°RESTå¤‡ç”¨æ¨¡å¼"
                            )
                            ws_should_fail = True

                    # ğŸ”¥ æ¡ä»¶2ï¼šå‰¥å¤´çš®æ¨¡å¼ä¸‹æŒä»“ä¸º0ï¼ˆå¼‚å¸¸æƒ…å†µï¼‰
                    if self.scalping_manager and self.scalping_manager.is_active():
                        current_position = self.tracker.get_current_position()
                        if abs(current_position) == 0:
                            self.logger.warning(
                                f"âš ï¸ WebSocketå¼‚å¸¸: å‰¥å¤´çš®æ¨¡å¼ä¸‹æŒä»“ä¸º0ï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼‰ï¼Œ"
                                f"åˆ‡æ¢åˆ°RESTå¤‡ç”¨æ¨¡å¼"
                            )
                            ws_should_fail = True

                    if ws_should_fail:
                        self._position_ws_enabled = False

                # ğŸ”¥ æ¡ä»¶3ï¼šå®šæœŸRESTæ ¡éªŒï¼ˆæ¯åˆ†é’Ÿå¿ƒè·³æ£€æµ‹ï¼‰
                if self._position_ws_enabled:
                    time_since_last_verify = current_time - self._last_position_rest_verify_time

                    if time_since_last_verify >= self._position_rest_verify_interval:
                        try:
                            # ä½¿ç”¨REST APIè·å–å®æ—¶æŒä»“
                            positions = await self.engine.exchange.get_positions([self.config.symbol])

                            if positions and len(positions) > 0:
                                position = positions[0]
                                rest_position = position.size or Decimal('0')

                                # æ ¹æ®æ–¹å‘ç¡®å®šæŒä»“ç¬¦å·
                                if hasattr(position, 'side'):
                                    from ....adapters.exchanges import PositionSide
                                    if position.side == PositionSide.SHORT and rest_position != 0:
                                        rest_position = -rest_position

                                # å¯¹æ¯”WebSocketæŒä»“å’ŒRESTæŒä»“
                                ws_position = self._last_ws_position_size

                                # å…è®¸å¾®å°è¯¯å·®ï¼ˆ0.01ï¼‰
                                position_diff = abs(
                                    rest_position - ws_position)

                                if position_diff > Decimal('0.01'):
                                    self.logger.warning(
                                        f"âš ï¸ WebSocketæŒä»“æ ¡éªŒå¤±è´¥: "
                                        f"WS={ws_position}, REST={rest_position}, "
                                        f"å·®å¼‚={position_diff}, åˆ‡æ¢åˆ°RESTå¤‡ç”¨æ¨¡å¼"
                                    )
                                    self._position_ws_enabled = False

                                    # ç«‹å³ç”¨RESTæ•°æ®æ›´æ–°æŒä»“
                                    if self.scalping_manager and self.scalping_manager.is_active():
                                        initial_capital = self.scalping_manager.get_initial_capital()
                                        self.scalping_manager.update_position(
                                            rest_position, position.entry_price,
                                            initial_capital, self._collateral_balance
                                        )
                                        self._last_ws_position_size = rest_position
                                        self._last_ws_position_price = position.entry_price

                                        # æ›´æ–°æ­¢ç›ˆè®¢å•
                                        await self._update_take_profit_order_if_needed()
                                else:
                                    # ğŸ”¥ ä½¿ç”¨INFOçº§åˆ«ï¼Œç¡®ä¿ç”¨æˆ·èƒ½çœ‹åˆ°æ ¡éªŒæ­£åœ¨è¿›è¡Œ
                                    self.logger.info(
                                        f"âœ… WebSocketæŒä»“æ ¡éªŒé€šè¿‡: WS={ws_position}, REST={rest_position}"
                                    )

                            self._last_position_rest_verify_time = current_time

                        except Exception as e:
                            self.logger.warning(f"âš ï¸ RESTæŒä»“æ ¡éªŒå¤±è´¥: {e}")
                            self._last_position_rest_verify_time = current_time

                # ğŸ”„ RESTå¤‡ç”¨åŒæ­¥ï¼ˆä»…å½“WebSocketå¤±è´¥æ—¶å¯ç”¨ï¼Œæ¯ç§’è½®è¯¢ï¼‰
                if not self._position_ws_enabled:
                    if current_time - self._last_position_rest_sync > rest_sync_interval:
                        try:
                            positions = await self.engine.exchange.get_positions([self.config.symbol])
                            if positions:
                                position = positions[0]
                                position_qty = position.size if position.side.value.lower() == 'long' else - \
                                    position.size

                                # åŒæ­¥åˆ°æŒä»“è¿½è¸ªå™¨
                                self.tracker.sync_initial_position(
                                    position=position_qty,
                                    entry_price=position.entry_price
                                )
                                self._last_position_rest_sync = current_time

                                # ğŸ”¥ å‰¥å¤´çš®æ¨¡å¼ï¼šæ£€æŸ¥æŒä»“å˜åŒ–å¹¶æ›´æ–°æ­¢ç›ˆè®¢å•
                                if self.scalping_manager and self.scalping_manager.is_active():
                                    old_position = self._last_ws_position_size

                                    if position_qty != old_position:
                                        # æ›´æ–°ScalpingManager
                                        initial_capital = self.scalping_manager.get_initial_capital()
                                        self.scalping_manager.update_position(
                                            position_qty, position.entry_price,
                                            initial_capital, self._collateral_balance
                                        )

                                        # æ›´æ–°æ­¢ç›ˆè®¢å•
                                        await self._update_take_profit_order_if_needed()

                                        # æ›´æ–°è®°å½•
                                        self._last_ws_position_size = position_qty
                                        self._last_ws_position_price = position.entry_price

                                        self.logger.info(
                                            f"ğŸ“¡ RESTå¤‡ç”¨åŒæ­¥: æ•°é‡ {old_position} â†’ {position_qty}, "
                                            f"æˆæœ¬=${position.entry_price:.2f}"
                                        )
                                    else:
                                        # ğŸ”¥ æŒä»“æœªå˜åŒ–ï¼Œä½†å®šæœŸæ‰“å°æ—¥å¿—è®©ç”¨æˆ·çŸ¥é“RESTå¤‡ç”¨åœ¨è¿è¡Œ
                                        if current_time - last_rest_log_time >= rest_log_interval:
                                            self.logger.info(
                                                f"ğŸ“¡ RESTå¤‡ç”¨æ¨¡å¼è¿è¡Œä¸­: {position.side.value} {position.size} @ ${position.entry_price:.2f}"
                                            )
                                            last_rest_log_time = current_time
                                else:
                                    # éå‰¥å¤´çš®æ¨¡å¼ï¼Œå®šæœŸè®°å½•æ—¥å¿—
                                    if current_time - last_rest_log_time >= rest_log_interval:
                                        self.logger.info(
                                            f"ğŸ“¡ RESTå¤‡ç”¨æ¨¡å¼è¿è¡Œä¸­: {position.side.value} {position.size} @ ${position.entry_price:.2f}"
                                        )
                                        last_rest_log_time = current_time
                            else:
                                self._last_position_rest_sync = current_time
                                # æ— æŒä»“æ—¶ä¹Ÿå®šæœŸæ‰“å°
                                if current_time - last_rest_log_time >= rest_log_interval:
                                    self.logger.info("ğŸ“¡ RESTå¤‡ç”¨æ¨¡å¼è¿è¡Œä¸­: æ— æŒä»“")
                                    last_rest_log_time = current_time
                        except Exception as e:
                            self.logger.warning(f"âš ï¸ RESTæŒä»“åŒæ­¥å¤±è´¥: {e}")

                # ğŸ”„ å°è¯•é‡è¿WebSocketï¼ˆå¦‚æœWebSocketå¤±è´¥ä¸”è¾¾åˆ°é‡è¿é—´éš”ï¼‰
                if not self._position_ws_enabled and (current_time - last_ws_reconnect_attempt > ws_reconnect_interval):
                    try:
                        self.logger.info("ğŸ”„ å°è¯•é‡æ–°è®¢é˜…WebSocketæŒä»“æ›´æ–°...")

                        if hasattr(self.engine.exchange, 'subscribe_position_updates'):
                            await self.engine.exchange.subscribe_position_updates(
                                self.config.symbol,
                                self._on_position_update
                            )
                            self._position_ws_enabled = True
                            self._last_position_ws_time = current_time
                            self.logger.info("âœ… WebSocketæŒä»“è®¢é˜…é‡è¿æˆåŠŸï¼")

                        last_ws_reconnect_attempt = current_time
                    except Exception as e:
                        self.logger.warning(f"âš ï¸ WebSocketé‡è¿å¤±è´¥: {e}")
                        last_ws_reconnect_attempt = current_time

            except asyncio.CancelledError:
                self.logger.info("ğŸ”„ æŒä»“åŒæ­¥ç›‘æ§ä»»åŠ¡å·²å–æ¶ˆ")
                break
            except Exception as e:
                self.logger.error(f"âŒ æŒä»“åŒæ­¥ç›‘æ§é”™è¯¯: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
                await asyncio.sleep(10)  # é”™è¯¯åç­‰å¾…10ç§’å†ç»§ç»­

        self.logger.info("ğŸ”„ æŒä»“åŒæ­¥ç›‘æ§ä»»åŠ¡å·²é€€å‡º")

    async def _on_order_filled(self, filled_order: GridOrder):
        """
        è®¢å•æˆäº¤å›è°ƒ - æ ¸å¿ƒé€»è¾‘

        å½“è®¢å•æˆäº¤æ—¶ï¼š
        1. è®°å½•æˆäº¤ä¿¡æ¯
        2. æ£€æŸ¥å‰¥å¤´çš®æ¨¡å¼
        3. è®¡ç®—åå‘è®¢å•å‚æ•°
        4. ç«‹å³æŒ‚åå‘è®¢å•

        Args:
            filled_order: å·²æˆäº¤è®¢å•
        """
        try:
            # ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šé˜²æ­¢åœ¨é‡ç½®æœŸé—´å¤„ç†è®¢å•
            if self._paused:
                self.logger.warning("ç³»ç»Ÿå·²æš‚åœï¼Œè·³è¿‡è®¢å•å¤„ç†")
                return

            if self._resetting:
                self.logger.warning("âš ï¸ ç³»ç»Ÿæ­£åœ¨é‡ç½®ä¸­ï¼Œè·³è¿‡è®¢å•å¤„ç†")
                return

            self.logger.info(
                f"ğŸ“¢ è®¢å•æˆäº¤: {filled_order.side.value} "
                f"{filled_order.filled_amount}@{filled_order.filled_price} "
                f"(Grid {filled_order.grid_id})"
            )

            # ğŸ”¥ è®°å½•è®¢å•æˆäº¤æ—¶é—´ï¼ˆç”¨äºåˆ¤æ–­WebSocketæ˜¯å¦å¤±æ•ˆï¼‰
            self._last_order_filled_time = time.time()

            # 1. æ›´æ–°çŠ¶æ€
            self.state.mark_order_filled(
                filled_order.order_id,
                filled_order.filled_price,
                filled_order.filled_amount or filled_order.amount
            )

            # 2. è®°å½•åˆ°æŒä»“è·Ÿè¸ªå™¨
            self.tracker.record_filled_order(filled_order)

            # ğŸ”¥ 3. æ£€æŸ¥å‰¥å¤´çš®æ¨¡å¼
            if self.scalping_manager:
                # æ£€æŸ¥æ˜¯å¦æ˜¯æ­¢ç›ˆè®¢å•æˆäº¤
                if self._is_take_profit_order_filled(filled_order):
                    await self._handle_take_profit_filled()
                    return  # æ­¢ç›ˆæˆäº¤åä¸å†æŒ‚åå‘è®¢å•

                # æ›´æ–°æŒä»“ä¿¡æ¯åˆ°å‰¥å¤´çš®ç®¡ç†å™¨
                current_position = self.tracker.get_current_position()
                average_cost = self.tracker.get_average_cost()
                initial_capital = self.scalping_manager.get_initial_capital()
                self.scalping_manager.update_position(
                    current_position, average_cost, initial_capital, self._collateral_balance)

                # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°æ­¢ç›ˆè®¢å•
                await self._update_take_profit_order_if_needed()

            # ğŸ›¡ï¸ 3.5. æ£€æŸ¥æœ¬é‡‘ä¿æŠ¤æ¨¡å¼
            if self.capital_protection_manager:
                current_price = filled_order.filled_price
                current_grid_index = self.config.find_nearest_grid_index(
                    current_price)
                await self._check_capital_protection_mode(current_price, current_grid_index)

            # 4. è®¡ç®—åå‘è®¢å•å‚æ•°
            # ğŸ”¥ å‰¥å¤´çš®æ¨¡å¼ä¸‹å¯èƒ½ä¸æŒ‚åå‘è®¢å•
            if self.scalping_manager and self.scalping_manager.is_active():
                # å‰¥å¤´çš®æ¨¡å¼ï¼šåªæŒ‚å»ºä»“å•ï¼Œä¸æŒ‚å¹³ä»“å•
                if not self._should_place_reverse_order_in_scalping(filled_order):
                    self.logger.info(f"ğŸ”´ å‰¥å¤´çš®æ¨¡å¼: ä¸æŒ‚åå‘è®¢å•")
                    return

            new_side, new_price, new_grid_id = self.strategy.calculate_reverse_order(
                filled_order,
                self.config.grid_interval,
                self.config.reverse_order_grid_distance
            )

            # 5. åˆ›å»ºåå‘è®¢å•
            reverse_order = GridOrder(
                order_id="",  # ç­‰å¾…æ‰§è¡Œå¼•æ“å¡«å……
                grid_id=new_grid_id,
                side=new_side,
                price=new_price,
                amount=filled_order.filled_amount or filled_order.amount,  # æ•°é‡å®Œå…¨ä¸€è‡´
                status=GridOrderStatus.PENDING,
                created_at=datetime.now(),
                parent_order_id=filled_order.order_id
            )

            # 6. ä¸‹åå‘è®¢å•
            placed_order = await self.engine.place_order(reverse_order)
            self.state.add_order(placed_order)

            # 7. è®°å½•å…³è”å…³ç³»
            filled_order.reverse_order_id = placed_order.order_id

            self.logger.info(
                f"âœ… åå‘è®¢å•å·²æŒ‚: {new_side.value} "
                f"{reverse_order.amount}@{new_price} "
                f"(Grid {new_grid_id})"
            )

            # 8. æ›´æ–°å½“å‰ä»·æ ¼
            current_price = await self.engine.get_current_price()
            current_grid_id = self.config.get_grid_index_by_price(
                current_price)
            self.state.update_current_price(current_price, current_grid_id)

            # ğŸ”¥ 9. æ£€æŸ¥æ˜¯å¦è§¦å‘æˆ–é€€å‡ºå‰¥å¤´çš®æ¨¡å¼
            await self._check_scalping_mode(current_price, current_grid_id)

            # é‡ç½®é”™è¯¯è®¡æ•°
            self._error_count = 0

        except Exception as e:
            self.logger.error(f"âŒ å¤„ç†è®¢å•æˆäº¤å¤±è´¥: {e}")
            self._handle_error(e)

    async def _on_batch_orders_filled(self, filled_orders: List[GridOrder]):
        """
        æ‰¹é‡è®¢å•æˆäº¤å¤„ç†

        å¤„ç†ä»·æ ¼å‰§çƒˆæ³¢åŠ¨å¯¼è‡´çš„å¤šè®¢å•åŒæ—¶æˆäº¤

        Args:
            filled_orders: å·²æˆäº¤è®¢å•åˆ—è¡¨
        """
        try:
            # ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šé˜²æ­¢åœ¨é‡ç½®æœŸé—´å¤„ç†è®¢å•
            if self._paused:
                self.logger.warning("ç³»ç»Ÿå·²æš‚åœï¼Œè·³è¿‡æ‰¹é‡è®¢å•å¤„ç†")
                return

            if self._resetting:
                self.logger.warning("âš ï¸ ç³»ç»Ÿæ­£åœ¨é‡ç½®ä¸­ï¼Œè·³è¿‡æ‰¹é‡è®¢å•å¤„ç†")
                return

            self.logger.info(
                f"âš¡ æ‰¹é‡æˆäº¤: {len(filled_orders)}ä¸ªè®¢å•"
            )

            # 1. æ‰¹é‡æ›´æ–°çŠ¶æ€å’Œè®°å½•
            for order in filled_orders:
                self.state.mark_order_filled(
                    order.order_id,
                    order.filled_price,
                    order.filled_amount or order.amount
                )
                self.tracker.record_filled_order(order)

            # 2. æ‰¹é‡è®¡ç®—åå‘è®¢å•
            reverse_params = self.strategy.calculate_batch_reverse_orders(
                filled_orders,
                self.config.grid_interval,
                self.config.reverse_order_grid_distance
            )

            # 3. åˆ›å»ºåå‘è®¢å•åˆ—è¡¨
            reverse_orders = []
            for side, price, grid_id, amount in reverse_params:
                order = GridOrder(
                    order_id="",
                    grid_id=grid_id,
                    side=side,
                    price=price,
                    amount=amount,
                    status=GridOrderStatus.PENDING,
                    created_at=datetime.now()
                )
                reverse_orders.append(order)

            # 4. æ‰¹é‡ä¸‹å•
            placed_orders = await self.engine.place_batch_orders(reverse_orders)

            # 5. æ‰¹é‡æ›´æ–°çŠ¶æ€
            for order in placed_orders:
                self.state.add_order(order)

            self.logger.info(
                f"âœ… æ‰¹é‡åå‘è®¢å•å·²æŒ‚: {len(placed_orders)}ä¸ª"
            )

            # 6. æ›´æ–°å½“å‰ä»·æ ¼
            current_price = await self.engine.get_current_price()
            current_grid_id = self.config.get_grid_index_by_price(
                current_price)
            self.state.update_current_price(current_price, current_grid_id)

            # é‡ç½®é”™è¯¯è®¡æ•°
            self._error_count = 0

        except Exception as e:
            self.logger.error(f"âŒ æ‰¹é‡å¤„ç†è®¢å•æˆäº¤å¤±è´¥: {e}")
            self._handle_error(e)

    def _handle_error(self, error: Exception):
        """
        å¤„ç†å¼‚å¸¸

        ç­–ç•¥ï¼š
        1. è®°å½•é”™è¯¯
        2. å¢åŠ é”™è¯¯è®¡æ•°
        3. è¶…è¿‡é˜ˆå€¼åˆ™æš‚åœç³»ç»Ÿ

        Args:
            error: å¼‚å¸¸å¯¹è±¡
        """
        self._error_count += 1

        self.logger.error(
            f"å¼‚å¸¸å‘ç”Ÿ ({self._error_count}/{self._max_errors}): {error}"
        )

        # å¦‚æœé”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œæš‚åœç³»ç»Ÿ
        if self._error_count >= self._max_errors:
            self.logger.error(
                f"âŒ é”™è¯¯æ¬¡æ•°è¾¾åˆ°ä¸Šé™({self._max_errors})ï¼Œæš‚åœç³»ç»Ÿ"
            )
            asyncio.create_task(self.pause())

    async def start(self):
        """å¯åŠ¨ç½‘æ ¼ç³»ç»Ÿ"""
        if self._running:
            self.logger.warning("ç½‘æ ¼ç³»ç»Ÿå·²ç»åœ¨è¿è¡Œ")
            return

        await self.initialize()
        await self.engine.start()

        # ğŸ”¥ ä¸»åŠ¨åŒæ­¥åˆå§‹æŒä»“åˆ°WebSocketç¼“å­˜
        # Backpackçš„WebSocketåªåœ¨æŒä»“å˜åŒ–æ—¶æ¨é€ï¼Œä¸ä¼šæ¨é€åˆå§‹çŠ¶æ€
        # æ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨å¯åŠ¨æ—¶ä¸»åŠ¨è·å–ä¸€æ¬¡
        position_data = {'size': Decimal('0'), 'entry_price': Decimal(
            '0'), 'unrealized_pnl': Decimal('0')}
        try:
            self.logger.info("ğŸ“Š æ­£åœ¨åŒæ­¥åˆå§‹æŒä»“æ•°æ®...")
            position_data = await self.engine.get_real_time_position(self.config.symbol)

            # å¦‚æœWebSocketç¼“å­˜ä¸ºç©ºï¼Œä½¿ç”¨REST APIè·å–å¹¶åŒæ­¥
            if position_data['size'] == 0 and position_data['entry_price'] == 0:
                positions = await self.engine.exchange.get_positions(symbols=[self.config.symbol])
                if positions and len(positions) > 0:
                    position = positions[0]
                    real_size = position.size or Decimal('0')
                    real_entry_price = position.entry_price or Decimal('0')

                    # åŒæ­¥åˆ°WebSocketç¼“å­˜
                    if hasattr(self.engine.exchange, '_position_cache'):
                        self.engine.exchange._position_cache[self.config.symbol] = {
                            'size': real_size,
                            'entry_price': real_entry_price,
                            'unrealized_pnl': position.unrealized_pnl or Decimal('0'),
                            'side': 'Long' if real_size > 0 else 'Short',
                            'timestamp': datetime.now()
                        }
                        self.logger.info(
                            f"âœ… åˆå§‹æŒä»“å·²åŒæ­¥åˆ°WebSocketç¼“å­˜: "
                            f"{real_size} {self.config.symbol.split('_')[0]}, "
                            f"æˆæœ¬=${real_entry_price:,.2f}"
                        )
                        # æ›´æ–°position_dataä¾›åç»­ä½¿ç”¨
                        position_data = {
                            'size': real_size,
                            'entry_price': real_entry_price,
                            'unrealized_pnl': position.unrealized_pnl or Decimal('0')
                        }
            else:
                # WebSocketç¼“å­˜å·²æœ‰æ•°æ®
                self.logger.info(
                    f"âœ… WebSocketç¼“å­˜å·²æœ‰æŒä»“æ•°æ®: "
                    f"{position_data['size']} {self.config.symbol.split('_')[0]}, "
                    f"æˆæœ¬=${position_data['entry_price']:,.2f}"
                )
        except Exception as e:
            self.logger.warning(f"åŒæ­¥åˆå§‹æŒä»“å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰: {e}")

        # ğŸ”¥ æ£€æŸ¥æ˜¯å¦åº”è¯¥ç«‹å³æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼
        # å¦‚æœå¯åŠ¨æ—¶å·²æœ‰æŒä»“ï¼Œä¸”ä»·æ ¼å·²åœ¨è§¦å‘é˜ˆå€¼ä»¥ä¸‹ï¼Œç«‹å³æ¿€æ´»
        if self.config.is_scalping_enabled():
            try:
                current_price = await self.engine.get_current_price()
                current_grid_id = self.config.get_grid_index_by_price(
                    current_price)

                # æ›´æ–°scalping_managerçš„æŒä»“ä¿¡æ¯
                if position_data['size'] != 0:
                    initial_capital = self.scalping_manager.get_initial_capital()
                    self.scalping_manager.update_position(
                        position_data['size'],
                        position_data['entry_price'],
                        initial_capital,
                        self._collateral_balance
                    )

                # æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å‰¥å¤´çš®æ¨¡å¼ï¼ˆéœ€è¦ä¼ é€’current_priceå’Œcurrent_grid_idï¼‰
                if self.scalping_manager.should_trigger(current_price, current_grid_id):
                    self.logger.info(
                        f"ğŸ¯ æ£€æµ‹åˆ°å¯åŠ¨æ—¶å·²åœ¨è§¦å‘åŒºåŸŸ (Grid {current_grid_id} <= "
                        f"Grid {self.config.get_scalping_trigger_grid()})ï¼Œç«‹å³æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼"
                    )
                    await self._activate_scalping_mode()
                else:
                    self.logger.info(
                        f"ğŸ“Š å‰¥å¤´çš®æ¨¡å¼å¾…è§¦å‘ (å½“å‰: Grid {current_grid_id}, "
                        f"è§¦å‘ç‚¹: Grid {self.config.get_scalping_trigger_grid()})"
                    )
            except Exception as e:
                self.logger.warning(f"æ£€æŸ¥å‰¥å¤´çš®æ¨¡å¼å¤±è´¥: {e}")
                import traceback
                self.logger.error(traceback.format_exc())

        # ğŸ”¥ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šå¯åŠ¨ä»·æ ¼è„±ç¦»ç›‘æ§
        if self.config.is_follow_mode():
            asyncio.create_task(self._price_escape_monitor())
            self.logger.info("âœ… ä»·æ ¼è„±ç¦»ç›‘æ§å·²å¯åŠ¨")

        # ğŸ’° å¯åŠ¨ä½™é¢è½®è¯¢ç›‘æ§
        self._balance_monitor_task = asyncio.create_task(
            self._balance_monitor_loop())
        self.logger.info(f"âœ… è´¦æˆ·ä½™é¢è½®è¯¢å·²å¯åŠ¨ï¼ˆé—´éš”{self._balance_update_interval}ç§’ï¼‰")

        self.logger.info("ğŸš€ ç½‘æ ¼ç³»ç»Ÿå·²å¯åŠ¨")

    async def pause(self):
        """æš‚åœç½‘æ ¼ç³»ç»Ÿï¼ˆä¿ç•™æŒ‚å•ï¼‰"""
        self._paused = True
        self.state.pause()

        self.logger.info("â¸ï¸ ç½‘æ ¼ç³»ç»Ÿå·²æš‚åœ")

    async def resume(self):
        """æ¢å¤ç½‘æ ¼ç³»ç»Ÿ"""
        self._paused = False
        self._error_count = 0  # é‡ç½®é”™è¯¯è®¡æ•°
        self.state.resume()

        self.logger.info("â–¶ï¸ ç½‘æ ¼ç³»ç»Ÿå·²æ¢å¤")

    async def stop(self):
        """åœæ­¢ç½‘æ ¼ç³»ç»Ÿï¼ˆå–æ¶ˆæ‰€æœ‰æŒ‚å•ï¼‰"""
        self._running = False
        self._paused = False

        # ğŸ’° åœæ­¢ä½™é¢ç›‘æ§ä»»åŠ¡
        if self._balance_monitor_task:
            self._balance_monitor_task.cancel()
            try:
                await self._balance_monitor_task
            except asyncio.CancelledError:
                pass
            self.logger.info("âœ… ä½™é¢ç›‘æ§å·²åœæ­¢")

        # ğŸ”„ åœæ­¢æŒä»“åŒæ­¥ç›‘æ§ä»»åŠ¡
        if hasattr(self, '_position_sync_task') and self._position_sync_task:
            self._position_sync_task.cancel()
            try:
                await self._position_sync_task
            except asyncio.CancelledError:
                pass
            self.logger.info("âœ… æŒä»“åŒæ­¥ç›‘æ§å·²åœæ­¢")

        # å–æ¶ˆæ‰€æœ‰æŒ‚å•
        cancelled_count = await self.engine.cancel_all_orders()
        self.logger.info(f"å–æ¶ˆäº†{cancelled_count}ä¸ªæŒ‚å•")

        # åœæ­¢å¼•æ“
        await self.engine.stop()

        # æ›´æ–°çŠ¶æ€
        self.state.stop()

        self.logger.info("â¹ï¸ ç½‘æ ¼ç³»ç»Ÿå·²åœæ­¢")

    async def get_statistics(self) -> GridStatistics:
        """
        è·å–ç»Ÿè®¡æ•°æ®ï¼ˆä¼˜å…ˆä½¿ç”¨WebSocketçœŸå®æŒä»“ï¼‰

        Returns:
            ç½‘æ ¼ç»Ÿè®¡æ•°æ®
        """
        # æ›´æ–°å½“å‰ä»·æ ¼
        try:
            current_price = await self.engine.get_current_price()
            current_grid_id = self.config.get_grid_index_by_price(
                current_price)
            self.state.update_current_price(current_price, current_grid_id)
        except Exception as e:
            self.logger.warning(f"è·å–å½“å‰ä»·æ ¼å¤±è´¥: {e}")

        # ğŸ”¥ åŒæ­¥engineçš„æœ€æ–°è®¢å•ç»Ÿè®¡åˆ°state
        self._sync_orders_from_engine()

        # è·å–ç»Ÿè®¡æ•°æ®ï¼ˆæœ¬åœ°è¿½è¸ªå™¨ï¼‰
        stats = self.tracker.get_statistics()

        # ğŸ”¥ ä¼˜å…ˆä½¿ç”¨WebSocketç¼“å­˜çš„çœŸå®æŒä»“æ•°æ®ï¼ˆä½†éœ€è¦æ£€æŸ¥WebSocketæ˜¯å¦å¯ç”¨ï¼‰
        # æ³¨æ„ï¼šåªæœ‰åœ¨WebSocketç¼“å­˜æœ‰æ•ˆä¸”WebSocketç›‘æ§æ­£å¸¸æ—¶æ‰ä½¿ç”¨ç¼“å­˜
        try:
            position_data = await self.engine.get_real_time_position(self.config.symbol)
            ws_position = position_data['size']
            ws_entry_price = position_data['entry_price']
            has_cache = position_data.get('has_cache', False)

            # ğŸ”¥ å…³é”®ä¿®å¤ï¼šåªæœ‰åœ¨WebSocketå¯ç”¨ä¸”ç¼“å­˜æœ‰æ•ˆæ—¶æ‰ä½¿ç”¨WebSocketç¼“å­˜
            # å¦‚æœWebSocketå·²å¤±æ•ˆï¼ˆåˆ‡æ¢åˆ°RESTå¤‡ç”¨æ¨¡å¼ï¼‰ï¼Œåˆ™ä½¿ç”¨PositionTrackeræ•°æ®
            if has_cache and self._position_ws_enabled:
                stats.current_position = ws_position
                stats.average_cost = ws_entry_price
                stats.position_data_source = "WebSocketç¼“å­˜"  # ğŸ”¥ æ ‡è®°æ•°æ®æ¥æº

                # é‡æ–°è®¡ç®—æœªå®ç°ç›ˆäºï¼ˆä½¿ç”¨WebSocketçš„çœŸå®æŒä»“ï¼‰
                if ws_position != 0 and current_price > 0:
                    stats.unrealized_profit = ws_position * \
                        (current_price - ws_entry_price)

                self.logger.debug(
                    f"ğŸ“Š ä½¿ç”¨WebSocketç¼“å­˜æŒä»“: {ws_position}, æˆæœ¬=${ws_entry_price}"
                )
            else:
                # WebSocketå¤±æ•ˆæˆ–ç¼“å­˜æ— æ•ˆï¼Œä½¿ç”¨PositionTrackerçš„æ•°æ®
                # åˆ¤æ–­PositionTrackerçš„æ•°æ®æ¥æº
                if self._position_ws_enabled:
                    stats.position_data_source = "WebSocketå›è°ƒ"  # ğŸ”¥ é€šè¿‡WebSocketå›è°ƒåŒæ­¥åˆ°Tracker
                else:
                    stats.position_data_source = "REST APIå¤‡ç”¨"  # ğŸ”¥ é€šè¿‡REST APIå¤‡ç”¨æ¨¡å¼åŒæ­¥åˆ°Tracker

                self.logger.debug(
                    f"ğŸ“Š ä½¿ç”¨PositionTracker: {stats.current_position}, "
                    f"æˆæœ¬=${stats.average_cost}, æ¥æº={stats.position_data_source} "
                    f"(WSå¯ç”¨={self._position_ws_enabled}, ç¼“å­˜={has_cache})"
                )
        except Exception as e:
            # å¦‚æœè·å–WebSocketæ•°æ®å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è¿½è¸ªå™¨çš„æ•°æ®
            stats.position_data_source = "PositionTracker"  # ğŸ”¥ é™çº§åˆ°Tracker
            self.logger.debug(f"è·å–WebSocketæŒä»“å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°è¿½è¸ªå™¨æ•°æ®: {e}")

        # ğŸ”¥ æ·»åŠ ç›‘æ§æ–¹å¼ä¿¡æ¯
        stats.monitoring_mode = self.engine.get_monitoring_mode()

        # ğŸ’° ä½¿ç”¨çœŸå®çš„è´¦æˆ·ä½™é¢ï¼ˆä» collateral API è½®è¯¢è·å–ï¼‰
        stats.spot_balance = self._spot_balance
        stats.collateral_balance = self._collateral_balance
        stats.order_locked_balance = self._order_locked_balance
        stats.total_balance = self._spot_balance + \
            self._collateral_balance + self._order_locked_balance

        # ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤æ¨¡å¼çŠ¶æ€
        if self.capital_protection_manager:
            stats.capital_protection_enabled = True
            stats.capital_protection_active = self.capital_protection_manager.is_active()
            stats.initial_capital = self.capital_protection_manager.get_initial_capital()
            stats.capital_profit_loss = self.capital_protection_manager.get_profit_loss(
                self._collateral_balance)

        # ğŸ”„ ä»·æ ¼è„±ç¦»ç›‘æ§çŠ¶æ€ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨ï¼‰
        if self.config.is_follow_mode() and self._price_escape_start_time is not None:
            import time
            escape_duration = int(time.time() - self._price_escape_start_time)
            stats.price_escape_active = True
            stats.price_escape_duration = escape_duration
            stats.price_escape_timeout = self.config.follow_timeout
            stats.price_escape_remaining = max(
                0, self.config.follow_timeout - escape_duration)

            # åˆ¤æ–­è„±ç¦»æ–¹å‘
            if current_price < self.config.lower_price:
                stats.price_escape_direction = "down"
            elif current_price > self.config.upper_price:
                stats.price_escape_direction = "up"

        # ğŸ’° æ­¢ç›ˆæ¨¡å¼çŠ¶æ€
        if self.take_profit_manager:
            stats.take_profit_enabled = True
            stats.take_profit_active = self.take_profit_manager.is_active()
            stats.take_profit_initial_capital = self.take_profit_manager.get_initial_capital()
            stats.take_profit_current_profit = self.take_profit_manager.get_profit_amount(
                self._collateral_balance)
            stats.take_profit_profit_rate = self.take_profit_manager.get_profit_percentage(
                self._collateral_balance)
            stats.take_profit_threshold = self.config.take_profit_percentage * 100  # è½¬ä¸ºç™¾åˆ†æ¯”

        # ğŸ”’ ä»·æ ¼é”å®šæ¨¡å¼çŠ¶æ€
        if self.price_lock_manager:
            stats.price_lock_enabled = True
            stats.price_lock_active = self.price_lock_manager.is_locked()
            stats.price_lock_threshold = self.config.price_lock_threshold

        return stats

    def get_state(self) -> GridState:
        """è·å–ç½‘æ ¼çŠ¶æ€"""
        return self.state

    def is_running(self) -> bool:
        """æ˜¯å¦è¿è¡Œä¸­"""
        return self._running and not self._paused

    def is_paused(self) -> bool:
        """æ˜¯å¦æš‚åœ"""
        return self._paused

    def is_stopped(self) -> bool:
        """æ˜¯å¦å·²åœæ­¢"""
        return not self._running

    def get_status_text(self) -> str:
        """è·å–çŠ¶æ€æ–‡æœ¬"""
        if self._paused:
            return "â¸ï¸ å·²æš‚åœ"
        elif self._running:
            return "ğŸŸ¢ è¿è¡Œä¸­"
        else:
            return "â¹ï¸ å·²åœæ­¢"

    async def _scalping_position_monitor_loop(self):
        """
        [å·²å¼ƒç”¨] å‰¥å¤´çš®æ¨¡å¼æŒä»“ç›‘æ§å¾ªç¯ï¼ˆREST APIè½®è¯¢æ–¹å¼ï¼‰

        âš ï¸ æ­¤æ–¹æ³•å·²è¢«WebSocketäº‹ä»¶é©±åŠ¨æ–¹å¼å–ä»£ï¼Œä¿ç•™ä»…ä½œå¤‡ä»½
        ç°åœ¨ä½¿ç”¨ _on_position_update_from_ws() å®æ—¶å¤„ç†æŒä»“æ›´æ–°
        """
        self.logger.warning("âš ï¸ ä½¿ç”¨äº†å·²å¼ƒç”¨çš„REST APIè½®è¯¢ç›‘æ§ï¼ˆåº”è¯¥ä½¿ç”¨WebSocketäº‹ä»¶é©±åŠ¨ï¼‰")
        self.logger.info("ğŸ“Š å‰¥å¤´çš®æŒä»“ç›‘æ§å¾ªç¯å·²å¯åŠ¨")

        last_position = Decimal('0')
        last_entry_price = Decimal('0')

        try:
            while self.scalping_manager and self.scalping_manager.is_active():
                try:
                    # ä»APIè·å–å®æ—¶æŒä»“
                    position_data = await self.engine.get_real_time_position(self.config.symbol)
                    current_position = position_data['size']
                    current_entry_price = position_data['entry_price']

                    # æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
                    position_changed = (
                        current_position != last_position or
                        current_entry_price != last_entry_price
                    )

                    if position_changed:
                        self.logger.info(
                            f"ğŸ“Š æŒä»“å˜åŒ–æ£€æµ‹: "
                            f"æ•°é‡ {last_position} â†’ {current_position}, "
                            f"æˆæœ¬ ${last_entry_price:,.2f} â†’ ${current_entry_price:,.2f}"
                        )

                        # æ›´æ–°å‰¥å¤´çš®ç®¡ç†å™¨çš„æŒä»“ä¿¡æ¯
                        initial_capital = self.scalping_manager.get_initial_capital()
                        self.scalping_manager.update_position(
                            current_position, current_entry_price, initial_capital, self._collateral_balance)

                        # æ›´æ–°æ­¢ç›ˆè®¢å•
                        await self._update_take_profit_order_after_position_change(
                            current_position,
                            current_entry_price
                        )

                        # æ›´æ–°è®°å½•
                        last_position = current_position
                        last_entry_price = current_entry_price

                    # ç­‰å¾…ä¸‹æ¬¡æ£€æŸ¥
                    await asyncio.sleep(self._scalping_position_check_interval)

                except asyncio.CancelledError:
                    raise
                except Exception as e:
                    self.logger.error(f"æŒä»“ç›‘æ§å‡ºé”™: {e}")
                    await asyncio.sleep(self._scalping_position_check_interval)

        except asyncio.CancelledError:
            self.logger.info("ğŸ“Š å‰¥å¤´çš®æŒä»“ç›‘æ§å¾ªç¯å·²å–æ¶ˆ")
        except Exception as e:
            self.logger.error(f"æŒä»“ç›‘æ§å¾ªç¯å¼‚å¸¸: {e}")
        finally:
            self.logger.info("ğŸ“Š å‰¥å¤´çš®æŒä»“ç›‘æ§å¾ªç¯å·²ç»“æŸ")

    async def _update_take_profit_order_after_position_change(
        self,
        new_position: Decimal,
        new_entry_price: Decimal
    ):
        """
        æŒä»“å˜åŒ–åæ›´æ–°æ­¢ç›ˆè®¢å•

        Args:
            new_position: æ–°çš„æŒä»“æ•°é‡
            new_entry_price: æ–°çš„å¹³å‡æˆæœ¬ä»·
        """
        if new_position == 0:
            # æŒä»“å½’é›¶ï¼Œå–æ¶ˆæ­¢ç›ˆè®¢å•
            if self.scalping_manager.get_current_take_profit_order():
                tp_order = self.scalping_manager.get_current_take_profit_order()
                try:
                    await self.engine.cancel_order(tp_order.order_id)
                    self.state.remove_order(tp_order.order_id)
                    self.logger.info("âœ… æŒä»“å½’é›¶ï¼Œå·²å–æ¶ˆæ­¢ç›ˆè®¢å•")
                except Exception as e:
                    self.logger.error(f"å–æ¶ˆæ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
            return

        # å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•
        old_tp_order = self.scalping_manager.get_current_take_profit_order()
        if old_tp_order:
            try:
                await self.engine.cancel_order(old_tp_order.order_id)
                self.state.remove_order(old_tp_order.order_id)
                self.logger.info(f"ğŸ”„ å·²å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•: {old_tp_order.order_id}")
            except Exception as e:
                self.logger.error(f"å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")

        # æŒ‚æ–°æ­¢ç›ˆè®¢å•
        await self._place_take_profit_order()
        self.logger.info("âœ… æ­¢ç›ˆè®¢å•å·²æ›´æ–°")

    async def _on_position_update_from_ws(self, position_info: Dict[str, Any]) -> None:
        """
        WebSocketæŒä»“æ›´æ–°å›è°ƒï¼ˆäº‹ä»¶é©±åŠ¨ï¼Œå®æ—¶å“åº”ï¼‰

        å½“WebSocketæ”¶åˆ°æŒä»“æ›´æ–°æ¨é€æ—¶è‡ªåŠ¨è°ƒç”¨
        """
        try:
            # åªåœ¨å‰¥å¤´çš®æ¨¡å¼æ¿€æ´»æ—¶å¤„ç†
            if not self.scalping_manager or not self.scalping_manager.is_active():
                return

            # åªå¤„ç†å½“å‰äº¤æ˜“å¯¹çš„æŒä»“
            if position_info.get('symbol') != self.config.symbol:
                return

            current_position = position_info.get('size', Decimal('0'))
            entry_price = position_info.get('entry_price', Decimal('0'))

            # æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
            position_changed = (
                current_position != self._last_ws_position_size or
                entry_price != self._last_ws_position_price
            )

            if position_changed:
                self.logger.info(
                    f"ğŸ“Š WebSocketæŒä»“å˜åŒ–: "
                    f"æ•°é‡ {self._last_ws_position_size} â†’ {current_position}, "
                    f"æˆæœ¬ ${self._last_ws_position_price:,.2f} â†’ ${entry_price:,.2f}"
                )

                # æ›´æ–°å‰¥å¤´çš®ç®¡ç†å™¨
                initial_capital = self.scalping_manager.get_initial_capital()
                self.scalping_manager.update_position(
                    current_position, entry_price, initial_capital, self._collateral_balance)

                # æ›´æ–°æ­¢ç›ˆè®¢å•
                await self._update_take_profit_order_after_position_change(
                    current_position,
                    entry_price
                )

                # æ›´æ–°è®°å½•
                self._last_ws_position_size = current_position
                self._last_ws_position_price = entry_price

        except Exception as e:
            self.logger.error(f"å¤„ç†WebSocketæŒä»“æ›´æ–°å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())

    def __repr__(self) -> str:
        return (
            f"GridCoordinator("
            f"status={self.get_status_text()}, "
            f"position={self.tracker.get_current_position()}, "
            f"errors={self._error_count})"
        )

    # ==================== ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨æ–¹æ³• ====================

    async def _price_escape_monitor(self):
        """
        ä»·æ ¼è„±ç¦»ç›‘æ§ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨ï¼‰

        å®šæœŸæ£€æŸ¥ä»·æ ¼æ˜¯å¦è„±ç¦»ç½‘æ ¼èŒƒå›´ï¼Œå¦‚æœè„±ç¦»æ—¶é—´è¶…è¿‡é˜ˆå€¼åˆ™é‡ç½®ç½‘æ ¼
        """
        import time

        self.logger.info("ğŸ” ä»·æ ¼è„±ç¦»ç›‘æ§å¾ªç¯å·²å¯åŠ¨")

        while self._running and not self._paused:
            try:
                current_time = time.time()

                # æ£€æŸ¥é—´éš”
                if current_time - self._last_escape_check_time < self._escape_check_interval:
                    await asyncio.sleep(1)
                    continue

                self._last_escape_check_time = current_time

                # è·å–å½“å‰ä»·æ ¼
                current_price = await self.engine.get_current_price()

                # æ£€æŸ¥æ˜¯å¦è„±ç¦»
                should_reset, direction = self.config.check_price_escape(
                    current_price)

                if should_reset:
                    # è®°å½•è„±ç¦»å¼€å§‹æ—¶é—´
                    if self._price_escape_start_time is None:
                        self._price_escape_start_time = current_time
                        self.logger.warning(
                            f"âš ï¸ ä»·æ ¼è„±ç¦»ç½‘æ ¼èŒƒå›´ï¼ˆ{direction}æ–¹å‘ï¼‰: "
                            f"å½“å‰ä»·æ ¼=${current_price:,.2f}, "
                            f"ç½‘æ ¼åŒºé—´=[${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                        )

                    # æ£€æŸ¥è„±ç¦»æ—¶é—´æ˜¯å¦è¶…è¿‡é˜ˆå€¼
                    escape_duration = current_time - self._price_escape_start_time

                    if escape_duration >= self.config.follow_timeout:
                        self.logger.warning(
                            f"ğŸ”„ ä»·æ ¼è„±ç¦»è¶…æ—¶ï¼ˆ{escape_duration:.0f}ç§’ >= {self.config.follow_timeout}ç§’ï¼‰ï¼Œ"
                            f"å‡†å¤‡é‡ç½®ç½‘æ ¼..."
                        )
                        await self._reset_grid_for_price_follow(current_price, direction)
                        self._price_escape_start_time = None
                    else:
                        self.logger.info(
                            f"â³ ä»·æ ¼è„±ç¦»ä¸­ï¼ˆ{direction}æ–¹å‘ï¼‰ï¼Œ"
                            f"å·²æŒç»­ {escape_duration:.0f}/{self.config.follow_timeout}ç§’"
                        )
                else:
                    # ä»·æ ¼å›åˆ°èŒƒå›´å†…ï¼Œé‡ç½®è„±ç¦»è®¡æ—¶
                    if self._price_escape_start_time is not None:
                        self.logger.info(
                            f"âœ… ä»·æ ¼å·²å›åˆ°ç½‘æ ¼èŒƒå›´å†…: ${current_price:,.2f}"
                        )
                        self._price_escape_start_time = None

                    # ğŸ”’ æ£€æŸ¥æ˜¯å¦éœ€è¦è§£é™¤ä»·æ ¼é”å®š
                    if self.price_lock_manager and self.price_lock_manager.is_locked():
                        if self.price_lock_manager.check_unlock_condition(
                            current_price,
                            self.config.lower_price,
                            self.config.upper_price
                        ):
                            self.price_lock_manager.deactivate_lock()
                            self.logger.info("ğŸ”“ ä»·æ ¼é”å®šå·²è§£é™¤ï¼Œæ¢å¤æ­£å¸¸ç½‘æ ¼äº¤æ˜“")

                await asyncio.sleep(1)

            except asyncio.CancelledError:
                self.logger.info("ä»·æ ¼è„±ç¦»ç›‘æ§å·²åœæ­¢")
                break
            except Exception as e:
                self.logger.error(f"ä»·æ ¼è„±ç¦»ç›‘æ§å‡ºé”™: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
                await asyncio.sleep(10)  # å‡ºé”™åç­‰å¾…10ç§’å†ç»§ç»­

    async def _reset_grid_for_price_follow(self, current_price: Decimal, direction: str):
        """
        é‡ç½®ç½‘æ ¼ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼ä¸“ç”¨ï¼‰

        Args:
            current_price: å½“å‰ä»·æ ¼
            direction: è„±ç¦»æ–¹å‘ ("up" æˆ– "down")
        """
        if self._is_resetting:
            self.logger.warning("ç½‘æ ¼æ­£åœ¨é‡ç½®ä¸­ï¼Œè·³è¿‡æœ¬æ¬¡é‡ç½®")
            return

        # ğŸ”’ æ£€æŸ¥æ˜¯å¦åº”è¯¥é”å®šè€Œä¸æ˜¯é‡ç½®
        if self.price_lock_manager:
            if self.price_lock_manager.should_lock_instead_of_reset(current_price, direction):
                # æ¿€æ´»ä»·æ ¼é”å®šï¼Œä¸æ‰§è¡Œé‡ç½®
                self.price_lock_manager.activate_lock(current_price)
                self.logger.info(
                    f"ğŸ”’ ä»·æ ¼é”å®šå·²æ¿€æ´»ï¼Œä¸æ‰§è¡Œé‡ç½®ã€‚"
                    f"ä¿ç•™è®¢å•å’ŒæŒä»“ï¼Œç­‰å¾…ä»·æ ¼å›å½’..."
                )
                return

        try:
            self._is_resetting = True

            self.logger.info(
                f"ğŸ”„ å¼€å§‹é‡ç½®ç½‘æ ¼: å½“å‰ä»·æ ¼=${current_price:,.2f}, è„±ç¦»æ–¹å‘={direction}"
            )

            # åˆ¤æ–­æ˜¯å¦éœ€è¦å¹³ä»“ï¼ˆä»·æ ¼æœæœ‰åˆ©æ–¹å‘è„±ç¦» = æ­¢ç›ˆï¼‰
            should_close_position = False
            if self.config.is_long() and direction == "up":
                # åšå¤š + ä»·æ ¼å‘ä¸Š = ç›ˆåˆ©æ–¹å‘ï¼Œéœ€è¦å¹³ä»“æ­¢ç›ˆ
                should_close_position = True
                self.logger.info("ğŸ“Š åšå¤šç½‘æ ¼ä»·æ ¼å‘ä¸Šè„±ç¦» â†’ éœ€è¦å¹³ä»“æ­¢ç›ˆ")
            elif self.config.is_short() and direction == "down":
                # åšç©º + ä»·æ ¼å‘ä¸‹ = ç›ˆåˆ©æ–¹å‘ï¼Œéœ€è¦å¹³ä»“æ­¢ç›ˆ
                should_close_position = True
                self.logger.info("ğŸ“Š åšç©ºç½‘æ ¼ä»·æ ¼å‘ä¸‹è„±ç¦» â†’ éœ€è¦å¹³ä»“æ­¢ç›ˆ")
            else:
                self.logger.info("ğŸ“Š ä»·æ ¼æœä¸åˆ©æ–¹å‘è„±ç¦» â†’ ä¿ç•™æŒä»“")

            # 1. å–æ¶ˆæ‰€æœ‰æŒ‚å•
            self.logger.info("ğŸ“‹ æ­¥éª¤ 1/7: å–æ¶ˆæ‰€æœ‰æŒ‚å•...")
            cancelled_count = await self.engine.cancel_all_orders()
            self.logger.info(f"æ‰¹é‡å–æ¶ˆAPIè¿”å›: {cancelled_count} ä¸ªè®¢å•")

            # 2. éªŒè¯æ‰€æœ‰è®¢å•æ˜¯å¦çœŸçš„è¢«å–æ¶ˆï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 2/7: éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€...")

            max_retries = 3  # æœ€å¤šé‡è¯•3æ¬¡
            retry_delay = 2  # æ¯æ¬¡é‡è¯•é—´éš”2ç§’

            for retry in range(max_retries):
                # ç­‰å¾…è®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
                if retry == 0:
                    await asyncio.sleep(1)  # é¦–æ¬¡éªŒè¯ç­‰å¾…1ç§’
                else:
                    await asyncio.sleep(retry_delay)  # é‡è¯•æ—¶ç­‰å¾…2ç§’

                # è·å–å½“å‰æœªæˆäº¤è®¢å•æ•°é‡
                open_orders = await self.engine.exchange.get_open_orders(self.config.symbol)
                open_count = len(open_orders)

                if open_count == 0:
                    # éªŒè¯æˆåŠŸ
                    self.logger.info(f"âœ… è®¢å•å–æ¶ˆéªŒè¯é€šè¿‡: å½“å‰æœªæˆäº¤è®¢å• {open_count} ä¸ª")
                    break
                else:
                    # éªŒè¯å¤±è´¥
                    if retry < max_retries - 1:
                        # è¿˜æœ‰é‡è¯•æœºä¼šï¼Œå°è¯•å†æ¬¡å–æ¶ˆ
                        self.logger.warning(
                            f"âš ï¸ ç¬¬ {retry + 1} æ¬¡éªŒè¯å¤±è´¥: ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                        )
                        self.logger.info(f"ğŸ”„ å°è¯•å†æ¬¡å–æ¶ˆè¿™äº›è®¢å•...")

                        # å†æ¬¡è°ƒç”¨å–æ¶ˆè®¢å•
                        retry_cancelled = await self.engine.cancel_all_orders()
                        self.logger.info(f"é‡è¯•å–æ¶ˆè¿”å›: {retry_cancelled} ä¸ªè®¢å•")
                    else:
                        # å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒ
                        self.logger.error(
                            f"âŒ è®¢å•å–æ¶ˆéªŒè¯æœ€ç»ˆå¤±è´¥ï¼å·²é‡è¯• {max_retries} æ¬¡ï¼Œä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                        )
                        self.logger.error(f"é¢„æœŸ: 0 ä¸ªè®¢å•, å®é™…: {open_count} ä¸ªè®¢å•")
                        self.logger.error("âš ï¸ ç½‘æ ¼é‡ç½®å·²æš‚åœï¼Œä¸ä¼šæŒ‚å‡ºæ–°è®¢å•ï¼Œé¿å…è¶…å‡ºè®¢å•é™åˆ¶")
                        self.logger.error("ğŸ’¡ å»ºè®®: è¯·æ‰‹åŠ¨æ£€æŸ¥äº¤æ˜“æ‰€è®¢å•ï¼Œæˆ–ç­‰å¾…ä¸‹æ¬¡ä»·æ ¼è„±ç¦»æ—¶è‡ªåŠ¨é‡è¯•")

                        # ä¸ç»§ç»­åç»­æ­¥éª¤ï¼Œç›´æ¥è¿”å›
                        return

            # 3. å¹³ä»“ï¼ˆå¦‚æœéœ€è¦ï¼‰
            new_capital = None  # ç”¨äºè®°å½•å¹³ä»“åçš„æ–°æœ¬é‡‘
            if should_close_position:
                current_position = self.tracker.get_current_position()
                if current_position != 0:
                    self.logger.info(
                        f"ğŸ“‹ æ­¥éª¤ 3/7: ä»·æ ¼è„±ç¦»å¹³ä»“æ­¢ç›ˆ: {current_position:+.4f}")
                    try:
                        # ä½¿ç”¨å¸‚ä»·å•å¹³ä»“
                        side = GridOrderSide.SELL if current_position > 0 else GridOrderSide.BUY
                        await self.engine.place_market_order(
                            side=side,
                            amount=abs(current_position)
                        )
                        self.logger.info("âœ… ä»·æ ¼è„±ç¦»å¹³ä»“å®Œæˆ")

                        # ç­‰å¾…å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
                        await asyncio.sleep(2)

                        # é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆå¹³ä»“åçš„æ–°æœ¬é‡‘ï¼‰
                        try:
                            await self._update_account_balance()
                            new_capital = self._collateral_balance
                            self.logger.info(
                                f"ğŸ“Š ä»·æ ¼è„±ç¦»å¹³ä»“åæ–°æœ¬é‡‘: ${new_capital:,.3f}")
                        except Exception as e:
                            self.logger.error(f"âš ï¸ è·å–å¹³ä»“åä½™é¢å¤±è´¥: {e}")
                    except Exception as e:
                        self.logger.error(f"âŒ ä»·æ ¼è„±ç¦»å¹³ä»“å¤±è´¥: {e}")
                        # å³ä½¿å¹³ä»“å¤±è´¥ä¹Ÿç»§ç»­é‡ç½®æµç¨‹
                else:
                    self.logger.info("ğŸ“‹ æ­¥éª¤ 3/7: æ— æŒä»“ï¼Œè·³è¿‡å¹³ä»“")
            else:
                self.logger.info("ğŸ“‹ æ­¥éª¤ 3/7: ä¸åˆ©æ–¹å‘è„±ç¦»ï¼Œä¿ç•™æŒä»“")

            # 4. æ¸…ç©ºçŠ¶æ€
            self.logger.info("ğŸ“‹ æ­¥éª¤ 4/7: æ¸…ç©ºç½‘æ ¼çŠ¶æ€...")
            self.state.active_orders.clear()
            self.state.pending_buy_orders = 0
            self.state.pending_sell_orders = 0
            self.logger.info("âœ… ç½‘æ ¼çŠ¶æ€å·²æ¸…ç©º")

            # 5. æ›´æ–°ä»·æ ¼åŒºé—´
            self.logger.info("ğŸ“‹ æ­¥éª¤ 5/7: æ›´æ–°ä»·æ ¼åŒºé—´...")
            old_range = (self.config.lower_price, self.config.upper_price)
            self.config.update_price_range_for_follow_mode(current_price)
            self.logger.info(
                f"âœ… ä»·æ ¼åŒºé—´å·²æ›´æ–°: "
                f"[${old_range[0]:,.2f}, ${old_range[1]:,.2f}] â†’ "
                f"[${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
            )

            # 6. é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§
            self.logger.info("ğŸ“‹ æ­¥éª¤ 6/7: é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§...")
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )
            self.logger.info(f"âœ… ç½‘æ ¼å±‚çº§å·²é‡æ–°åˆå§‹åŒ–ï¼Œå…±{self.config.grid_count}ä¸ª")

            # 7. ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•
            self.logger.info("ğŸ“‹ æ­¥éª¤ 7/7: ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•...")
            initial_orders = self.strategy.initialize(self.config)
            placed_orders = await self.engine.place_batch_orders(initial_orders)

            # æ·»åŠ åˆ°çŠ¶æ€
            for order in placed_orders:
                if order.order_id in self.state.active_orders:
                    continue
                if order.status == GridOrderStatus.FILLED:
                    continue
                self.state.add_order(order)

            # 8. å¦‚æœå¹³ä»“äº†ï¼Œé‡æ–°åˆå§‹åŒ–æœ¬é‡‘
            if new_capital is not None:
                if self.capital_protection_manager:
                    self.capital_protection_manager.initialize_capital(
                        new_capital, is_reinit=True)
                if self.take_profit_manager:
                    self.take_profit_manager.initialize_capital(
                        new_capital, is_reinit=True)
                if self.scalping_manager:
                    self.scalping_manager.initialize_capital(
                        new_capital, is_reinit=True)
                self.logger.info(f"ğŸ’° æœ¬é‡‘å·²é‡æ–°åˆå§‹åŒ–: ${new_capital:,.3f}")

            self.logger.info(
                f"âœ… ç½‘æ ¼é‡ç½®å®Œæˆï¼æˆåŠŸæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•ï¼Œ"
                f"æ–°ä»·æ ¼åŒºé—´: [${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
            )

        except Exception as e:
            self.logger.error(f"âŒ ç½‘æ ¼é‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            self._handle_error(e)
        finally:
            self._is_resetting = False

    # ===========================================
    # ğŸ”¥ å‰¥å¤´çš®æ¨¡å¼ç›¸å…³æ–¹æ³•
    # ===========================================

    async def _check_scalping_mode(self, current_price: Decimal, current_grid_index: int):
        """
        æ£€æŸ¥æ˜¯å¦è§¦å‘æˆ–é€€å‡ºå‰¥å¤´çš®æ¨¡å¼

        Args:
            current_price: å½“å‰ä»·æ ¼
            current_grid_index: å½“å‰ç½‘æ ¼ç´¢å¼•
        """
        if not self.scalping_manager:
            return

        # æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å‰¥å¤´çš®
        if self.scalping_manager.should_trigger(current_price, current_grid_index):
            await self._activate_scalping_mode()

        # æ£€æŸ¥æ˜¯å¦åº”è¯¥é€€å‡ºå‰¥å¤´çš®
        elif self.scalping_manager.should_exit(current_price, current_grid_index):
            await self._deactivate_scalping_mode()

    async def _verify_no_sell_orders_at_exchange(self, max_retries: int = 3) -> bool:
        """
        ä»äº¤æ˜“æ‰€éªŒè¯æ²¡æœ‰å–å•ï¼ˆåšå¤šç½‘æ ¼å‰¥å¤´çš®æ¨¡å¼ï¼‰

        Args:
            max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°

        Returns:
            True: ç¡®è®¤æ²¡æœ‰å–å•
            False: ä»æœ‰å–å•
        """
        for retry in range(max_retries):
            try:
                # ä»äº¤æ˜“æ‰€è·å–å½“å‰æŒ‚å•
                exchange_orders = await self.engine.exchange.get_open_orders(
                    symbol=self.config.symbol
                )

                # è¿‡æ»¤å‡ºå–å•
                sell_orders = [
                    order for order in exchange_orders
                    if order.side == GridOrderSide.SELL
                ]

                if len(sell_orders) == 0:
                    self.logger.info(f"âœ… éªŒè¯é€šè¿‡: äº¤æ˜“æ‰€ç¡®è®¤æ— å–å•")
                    return True
                else:
                    self.logger.warning(
                        f"âš ï¸ éªŒè¯å¤±è´¥ (å°è¯•{retry+1}/{max_retries}): "
                        f"äº¤æ˜“æ‰€ä»æœ‰{len(sell_orders)}ä¸ªå–å•"
                    )
                    for order in sell_orders:
                        self.logger.warning(
                            f"   æ®‹ç•™å–å•: {order.order_id}, "
                            f"ä»·æ ¼=${order.price}"
                        )

                    # å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•ï¼Œç­‰å¾…åå†éªŒè¯
                    if retry < max_retries - 1:
                        await asyncio.sleep(0.5)

            except Exception as e:
                self.logger.error(f"éªŒè¯å–å•å¤±è´¥: {e}")
                if retry < max_retries - 1:
                    await asyncio.sleep(0.5)

        return False

    async def _verify_take_profit_order_placed(
        self,
        expected_order_id: str,
        max_retries: int = 3
    ) -> bool:
        """
        éªŒè¯æ­¢ç›ˆè®¢å•å·²åœ¨äº¤æ˜“æ‰€æŒ‚å‡º

        Args:
            expected_order_id: é¢„æœŸçš„è®¢å•ID
            max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°

        Returns:
            True: è®¢å•å·²æŒ‚å‡º
            False: è®¢å•æœªæŒ‚å‡º
        """
        for retry in range(max_retries):
            try:
                # ä»äº¤æ˜“æ‰€è·å–å½“å‰æŒ‚å•
                exchange_orders = await self.engine.exchange.get_open_orders(
                    symbol=self.config.symbol
                )

                # æŸ¥æ‰¾æ­¢ç›ˆè®¢å•
                found = False
                for order in exchange_orders:
                    if order.order_id == expected_order_id:
                        found = True
                        self.logger.info(
                            f"âœ… éªŒè¯é€šè¿‡: æ­¢ç›ˆè®¢å•å·²æŒ‚å‡º "
                            f"{order.side.value} {order.amount}@${order.price}"
                        )
                        break

                if found:
                    return True
                else:
                    self.logger.warning(
                        f"âš ï¸ éªŒè¯å¤±è´¥ (å°è¯•{retry+1}/{max_retries}): "
                        f"äº¤æ˜“æ‰€æœªæ‰¾åˆ°è®¢å• {expected_order_id}"
                    )

                    if retry < max_retries - 1:
                        await asyncio.sleep(0.5)

            except Exception as e:
                self.logger.error(f"éªŒè¯æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
                if retry < max_retries - 1:
                    await asyncio.sleep(0.5)

        return False

    async def _cancel_all_sell_orders_with_verification(self, max_attempts: int = 3) -> bool:
        """
        å–æ¶ˆæ‰€æœ‰å–å•ï¼Œå¹¶éªŒè¯æˆåŠŸ

        å¾ªç¯é€»è¾‘ï¼š
        1. æ‰¹é‡å–æ¶ˆå–å•
        2. ä»äº¤æ˜“æ‰€éªŒè¯
        3. å¦‚æœè¿˜æœ‰æ®‹ç•™ï¼Œå†æ¬¡æ‰¹é‡å–æ¶ˆ
        4. é‡å¤æœ€å¤šmax_attemptsæ¬¡

        Args:
            max_attempts: æœ€å¤§å°è¯•æ¬¡æ•°

        Returns:
            True: æ‰€æœ‰å–å•å·²å–æ¶ˆ
            False: ä»æœ‰å–å•æ— æ³•å–æ¶ˆ
        """
        orders_to_cancel_type = "sell"

        for attempt in range(max_attempts):
            self.logger.info(
                f"ğŸ”„ å–æ¶ˆå–å•å°è¯• {attempt+1}/{max_attempts}..."
            )

            # 1. æ”¶é›†éœ€è¦å–æ¶ˆçš„å–å•ï¼ˆä»æœ¬åœ°çŠ¶æ€ï¼‰
            orders_to_cancel_list = []
            for order_id, order in list(self.state.active_orders.items()):
                if order.side == GridOrderSide.SELL:
                    orders_to_cancel_list.append(order)

            if len(orders_to_cancel_list) == 0:
                self.logger.info("ğŸ“‹ æœ¬åœ°çŠ¶æ€æ˜¾ç¤ºæ— å–å•ï¼ŒéªŒè¯äº¤æ˜“æ‰€...")
                # å³ä½¿æœ¬åœ°æ— å–å•ï¼Œä¹Ÿè¦éªŒè¯äº¤æ˜“æ‰€
                if await self._verify_no_sell_orders_at_exchange():
                    return True
                else:
                    # äº¤æ˜“æ‰€è¿˜æœ‰å–å•ï¼Œä½†æœ¬åœ°çŠ¶æ€æ²¡æœ‰ï¼Œéœ€è¦åŒæ­¥
                    self.logger.warning("âš ï¸ æœ¬åœ°çŠ¶æ€ä¸äº¤æ˜“æ‰€ä¸åŒæ­¥ï¼Œä»äº¤æ˜“æ‰€è·å–...")
                    try:
                        exchange_orders = await self.engine.exchange.get_open_orders(
                            symbol=self.config.symbol
                        )
                        orders_to_cancel_list = [
                            order for order in exchange_orders
                            if order.side == GridOrderSide.SELL
                        ]
                    except Exception as e:
                        self.logger.error(f"ä»äº¤æ˜“æ‰€è·å–è®¢å•å¤±è´¥: {e}")
                        continue

            self.logger.info(f"ğŸ“‹ å‡†å¤‡å–æ¶ˆ {len(orders_to_cancel_list)} ä¸ªå–å•")

            # 2. æ‰¹é‡å–æ¶ˆè®¢å•ï¼ˆå¹¶å‘ï¼Œæé«˜é€Ÿåº¦ï¼‰
            cancelled_count = 0
            failed_count = 0

            async def cancel_single_order(order):
                """å–æ¶ˆå•ä¸ªè®¢å•"""
                try:
                    await self.engine.cancel_order(order.order_id)
                    self.state.remove_order(order.order_id)
                    return True, order.order_id
                except Exception as e:
                    error_msg = str(e).lower()
                    if "not found" in error_msg or "does not exist" in error_msg:
                        # è®¢å•å·²ä¸å­˜åœ¨ï¼Œä»çŠ¶æ€ç§»é™¤
                        self.state.remove_order(order.order_id)
                        return True, order.order_id
                    else:
                        return False, order.order_id

            # å¹¶å‘å–æ¶ˆï¼ˆé™åˆ¶æ‰¹æ¬¡å¤§å°é¿å…APIé™æµï¼‰
            batch_size = 10
            for i in range(0, len(orders_to_cancel_list), batch_size):
                batch = orders_to_cancel_list[i:i+batch_size]
                tasks = [cancel_single_order(order) for order in batch]

                try:
                    results = await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=30.0
                    )

                    for result in results:
                        if isinstance(result, Exception):
                            failed_count += 1
                        elif result[0]:
                            cancelled_count += 1
                        else:
                            failed_count += 1

                except Exception as e:
                    self.logger.error(f"æ‰¹é‡å–æ¶ˆè®¢å•å¤±è´¥: {e}")
                    failed_count += len(batch)

                # é¿å…APIé™æµ
                if i + batch_size < len(orders_to_cancel_list):
                    await asyncio.sleep(0.1)

            self.logger.info(
                f"âœ… æ‰¹é‡å–æ¶ˆå®Œæˆ: æˆåŠŸ={cancelled_count}, å¤±è´¥={failed_count}"
            )

            # 3. ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
            await asyncio.sleep(0.3)

            # 4. ğŸ”¥ å…³é”®ï¼šä»äº¤æ˜“æ‰€éªŒè¯æ˜¯å¦è¿˜æœ‰å–å•
            if await self._verify_no_sell_orders_at_exchange():
                self.logger.info(f"âœ… æ‰€æœ‰å–å•å·²æˆåŠŸå–æ¶ˆï¼ˆå°è¯•{attempt+1}æ¬¡ï¼‰")
                return True
            else:
                self.logger.warning(
                    f"âš ï¸ äº¤æ˜“æ‰€ä»æœ‰å–å•æ®‹ç•™ï¼Œå‡†å¤‡ç¬¬{attempt+2}æ¬¡å°è¯•..."
                )
                # ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯

        # è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ï¼Œä»æœ‰å–å•
        self.logger.error(
            f"âŒ å–æ¶ˆå–å•å¤±è´¥: å·²å°è¯•{max_attempts}æ¬¡ï¼Œäº¤æ˜“æ‰€ä»æœ‰å–å•æ®‹ç•™"
        )
        return False

    async def _check_capital_protection_mode(self, current_price: Decimal, current_grid_index: int):
        """
        æ£€æŸ¥æ˜¯å¦è§¦å‘æœ¬é‡‘ä¿æŠ¤æ¨¡å¼

        Args:
            current_price: å½“å‰ä»·æ ¼
            current_grid_index: å½“å‰ç½‘æ ¼ç´¢å¼•
        """
        if not self.capital_protection_manager:
            return

        # å¦‚æœå·²ç»è§¦å‘ï¼Œæ£€æŸ¥æ˜¯å¦å›æœ¬
        if self.capital_protection_manager.is_active():
            # æ£€æŸ¥æŠµæŠ¼å“æ˜¯å¦å›æœ¬
            if self.capital_protection_manager.check_capital_recovery(self._collateral_balance):
                self.logger.warning(
                    f"ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤ï¼šæŠµæŠ¼å“å·²å›æœ¬ï¼Œå‡†å¤‡é‡ç½®ç½‘æ ¼ï¼"
                )
                await self._execute_capital_protection_reset()
        else:
            # æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘
            if self.capital_protection_manager.should_trigger(current_price, current_grid_index):
                self.capital_protection_manager.activate()
                self.logger.warning(
                    f"ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤å·²æ¿€æ´»ï¼ç­‰å¾…æŠµæŠ¼å“å›æœ¬... "
                    f"åˆå§‹æœ¬é‡‘: ${self.capital_protection_manager.get_initial_capital():,.2f}"
                )

    async def _execute_capital_protection_reset(self):
        """æ‰§è¡Œæœ¬é‡‘ä¿æŠ¤é‡ç½®ï¼ˆå¹³ä»“åé‡ç½®å¹¶é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰"""
        try:
            # ğŸ”¥ å…³é”®ï¼šè®¾ç½®é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢å¹¶å‘æ“ä½œ
            self._resetting = True
            self.logger.warning("ğŸ›¡ï¸ å¼€å§‹æ‰§è¡Œæœ¬é‡‘ä¿æŠ¤é‡ç½®ï¼ˆé”å®šç³»ç»Ÿï¼‰...")

            # 1. å–æ¶ˆæ‰€æœ‰è®¢å•ï¼ˆå¸¦éªŒè¯å’Œé‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 1/5: å–æ¶ˆæ‰€æœ‰è®¢å•...")
            try:
                cancelled_count = await self.engine.cancel_all_orders()
                self.logger.info(f"âœ… æ‰¹é‡å–æ¶ˆAPIè¿”å›: {cancelled_count} ä¸ªè®¢å•")
            except Exception as e:
                self.logger.error(f"âŒ æ‰¹é‡å–æ¶ˆè®¢å•å¤±è´¥: {e}")

            # 2. éªŒè¯æ‰€æœ‰è®¢å•æ˜¯å¦çœŸçš„è¢«å–æ¶ˆï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 2/5: éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€...")

            max_retries = 3  # æœ€å¤šé‡è¯•3æ¬¡
            retry_delay = 1.5  # æ¯æ¬¡é‡è¯•é—´éš”1.5ç§’
            cancel_verified = False

            for retry in range(max_retries):
                # ç­‰å¾…è®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
                if retry == 0:
                    await asyncio.sleep(0.8)  # é¦–æ¬¡éªŒè¯ç­‰å¾…0.8ç§’
                else:
                    await asyncio.sleep(retry_delay)  # é‡è¯•æ—¶ç­‰å¾…1.5ç§’

                # è·å–å½“å‰æœªæˆäº¤è®¢å•
                try:
                    open_orders = await self.engine.exchange.get_open_orders(self.config.symbol)
                    open_count = len(open_orders)

                    if open_count == 0:
                        # éªŒè¯æˆåŠŸ
                        self.logger.info(f"âœ… è®¢å•å–æ¶ˆéªŒè¯é€šè¿‡: å½“å‰æœªæˆäº¤è®¢å• {open_count} ä¸ª")
                        cancel_verified = True
                        break
                    else:
                        # éªŒè¯å¤±è´¥
                        if retry < max_retries - 1:
                            # è¿˜æœ‰é‡è¯•æœºä¼šï¼Œå°è¯•å†æ¬¡å–æ¶ˆ
                            self.logger.warning(
                                f"âš ï¸ ç¬¬ {retry + 1} æ¬¡éªŒè¯å¤±è´¥: ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                            )
                            self.logger.info(f"ğŸ”„ å°è¯•å†æ¬¡å–æ¶ˆè¿™äº›è®¢å•...")

                            # å†æ¬¡è°ƒç”¨å–æ¶ˆè®¢å•
                            try:
                                retry_cancelled = await self.engine.cancel_all_orders()
                                self.logger.info(
                                    f"é‡è¯•å–æ¶ˆè¿”å›: {retry_cancelled} ä¸ªè®¢å•")
                            except Exception as e:
                                self.logger.error(f"é‡è¯•å–æ¶ˆå¤±è´¥: {e}")
                        else:
                            # å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
                            self.logger.error(
                                f"âŒ è®¢å•å–æ¶ˆéªŒè¯æœ€ç»ˆå¤±è´¥ï¼å·²é‡è¯• {max_retries} æ¬¡ï¼Œä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                            )
                            self.logger.error(
                                f"é¢„æœŸ: 0 ä¸ªè®¢å•, å®é™…: {open_count} ä¸ªè®¢å•")
                            self.logger.error("âš ï¸ æœ¬é‡‘ä¿æŠ¤é‡ç½®å·²æš‚åœï¼Œä¸ä¼šç»§ç»­åç»­æ­¥éª¤")
                            return  # ç›´æ¥è¿”å›ï¼Œä¸ç»§ç»­æ‰§è¡Œ

                except Exception as e:
                    self.logger.error(f"éªŒè¯è®¢å•çŠ¶æ€å¤±è´¥: {e}")

            # ä»…åœ¨éªŒè¯æˆåŠŸåæ‰ç»§ç»­
            if not cancel_verified:
                self.logger.error("âŒ ç”±äºè®¢å•å–æ¶ˆéªŒè¯å¤±è´¥ï¼Œæœ¬é‡‘ä¿æŠ¤é‡ç½®å·²ä¸­æ­¢")
                return

            # 3. å¹³æ‰æ‰€æœ‰æŒä»“
            self.logger.info("ğŸ“‹ æ­¥éª¤ 3/5: å¹³ä»“...")
            current_position = self.tracker.get_current_position()
            if current_position != 0:
                self.logger.info(f"ğŸ“Š æœ¬é‡‘ä¿æŠ¤å¹³ä»“: {current_position:+.4f}")
                try:
                    # ä½¿ç”¨å¸‚ä»·å•å¹³ä»“
                    side = GridOrderSide.SELL if current_position > 0 else GridOrderSide.BUY
                    await self.engine.place_market_order(
                        side=side,
                        amount=abs(current_position)
                    )
                    self.logger.info("âœ… æœ¬é‡‘ä¿æŠ¤å¹³ä»“å®Œæˆ")
                except Exception as e:
                    self.logger.error(f"âŒ æœ¬é‡‘ä¿æŠ¤å¹³ä»“å¤±è´¥: {e}")
                    # å³ä½¿å¹³ä»“å¤±è´¥ä¹Ÿç»§ç»­é‡ç½®æµç¨‹

            # 4. ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
            await asyncio.sleep(2)

            # 5. é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆå¹³ä»“åçš„æ–°æœ¬é‡‘ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 4/5: è·å–æ–°æœ¬é‡‘...")
            try:
                await self._update_account_balance()
                new_capital = self._collateral_balance
                self.logger.info(f"ğŸ“Š æœ¬é‡‘ä¿æŠ¤åæ–°æœ¬é‡‘: ${new_capital:,.3f}")
            except Exception as e:
                self.logger.error(f"âš ï¸ è·å–å¹³ä»“åä½™é¢å¤±è´¥: {e}")
                new_capital = self._collateral_balance  # ä½¿ç”¨å½“å‰å€¼

            # 6. æ ¹æ®ç½‘æ ¼ç±»å‹å†³å®šåç»­æ“ä½œ
            self.logger.info("ğŸ“‹ æ­¥éª¤ 5/5: é‡æ–°å¯åŠ¨ç½‘æ ¼...")
            if self.config.is_follow_mode():
                # ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®å¹¶é‡æ–°å¯åŠ¨ï¼ˆé‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰
                # æ³¨æ„ï¼š_reset_and_restart å†…éƒ¨ä¹Ÿä¼šå–æ¶ˆè®¢å•å¹¶éªŒè¯ï¼Œä½†æˆ‘ä»¬å·²ç»æ¸…ç†è¿‡äº†
                # æ‰€ä»¥è¿™é‡Œéœ€è¦è·³è¿‡é‚£éƒ¨åˆ†ï¼Œç›´æ¥åˆå§‹åŒ–
                self.logger.info("ğŸ”„ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®ç½‘æ ¼å¹¶é‡æ–°å¯åŠ¨...")
                await self._reset_and_restart(new_capital=new_capital)
                self.logger.info("âœ… æœ¬é‡‘ä¿æŠ¤é‡ç½®å®Œæˆï¼Œç½‘æ ¼å·²é‡æ–°å¯åŠ¨")
            else:
                # å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šåœæ­¢è¿è¡Œ
                self.logger.info("â¹ï¸ å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šåœæ­¢è¿è¡Œ...")
                await self.stop()
                self.logger.warning("ğŸ›¡ï¸ æœ¬é‡‘ä¿æŠ¤ï¼šå›ºå®šèŒƒå›´ç½‘æ ¼å·²åœæ­¢ï¼Œè¯·æ‰‹åŠ¨é‡æ–°å¯åŠ¨")

        except Exception as e:
            self.logger.error(f"âŒ æœ¬é‡‘ä¿æŠ¤é‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
        finally:
            # ğŸ”¥ å…³é”®ï¼šæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é‡ç½®é”
            self._resetting = False
            self.logger.info("ğŸ”“ ç³»ç»Ÿé”å®šå·²é‡Šæ”¾")

    async def _execute_take_profit_reset(self):
        """æ‰§è¡Œæ­¢ç›ˆé‡ç½®ï¼ˆæ— è®ºå“ªç§ç½‘æ ¼éƒ½é‡ç½®å¹¶é‡å¯ï¼‰"""
        try:
            # ğŸ”¥ å…³é”®ï¼šè®¾ç½®é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢å¹¶å‘æ“ä½œ
            self._resetting = True
            self.logger.warning("ğŸ’° å¼€å§‹æ‰§è¡Œæ­¢ç›ˆé‡ç½®ï¼ˆé”å®šç³»ç»Ÿï¼‰...")

            # 1. å–æ¶ˆæ‰€æœ‰è®¢å•ï¼ˆå¸¦éªŒè¯å’Œé‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 1/5: å–æ¶ˆæ‰€æœ‰è®¢å•...")
            try:
                cancelled_count = await self.engine.cancel_all_orders()
                self.logger.info(f"âœ… æ‰¹é‡å–æ¶ˆAPIè¿”å›: {cancelled_count} ä¸ªè®¢å•")
            except Exception as e:
                self.logger.error(f"âŒ æ‰¹é‡å–æ¶ˆè®¢å•å¤±è´¥: {e}")

            # 2. éªŒè¯æ‰€æœ‰è®¢å•æ˜¯å¦çœŸçš„è¢«å–æ¶ˆï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 2/5: éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€...")

            max_retries = 3  # æœ€å¤šé‡è¯•3æ¬¡
            retry_delay = 1.5  # æ¯æ¬¡é‡è¯•é—´éš”1.5ç§’
            cancel_verified = False

            for retry in range(max_retries):
                # ç­‰å¾…è®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
                if retry == 0:
                    await asyncio.sleep(0.8)  # é¦–æ¬¡éªŒè¯ç­‰å¾…0.8ç§’
                else:
                    await asyncio.sleep(retry_delay)  # é‡è¯•æ—¶ç­‰å¾…1.5ç§’

                # è·å–å½“å‰æœªæˆäº¤è®¢å•
                try:
                    open_orders = await self.engine.exchange.get_open_orders(self.config.symbol)
                    open_count = len(open_orders)

                    if open_count == 0:
                        # éªŒè¯æˆåŠŸ
                        self.logger.info(f"âœ… è®¢å•å–æ¶ˆéªŒè¯é€šè¿‡: å½“å‰æœªæˆäº¤è®¢å• {open_count} ä¸ª")
                        cancel_verified = True
                        break
                    else:
                        # éªŒè¯å¤±è´¥
                        if retry < max_retries - 1:
                            # è¿˜æœ‰é‡è¯•æœºä¼šï¼Œå°è¯•å†æ¬¡å–æ¶ˆ
                            self.logger.warning(
                                f"âš ï¸ ç¬¬ {retry + 1} æ¬¡éªŒè¯å¤±è´¥: ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                            )
                            self.logger.info(f"ğŸ”„ å°è¯•å†æ¬¡å–æ¶ˆè¿™äº›è®¢å•...")

                            # å†æ¬¡è°ƒç”¨å–æ¶ˆè®¢å•
                            try:
                                retry_cancelled = await self.engine.cancel_all_orders()
                                self.logger.info(
                                    f"é‡è¯•å–æ¶ˆè¿”å›: {retry_cancelled} ä¸ªè®¢å•")
                            except Exception as e:
                                self.logger.error(f"é‡è¯•å–æ¶ˆå¤±è´¥: {e}")
                        else:
                            # å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
                            self.logger.error(
                                f"âŒ è®¢å•å–æ¶ˆéªŒè¯æœ€ç»ˆå¤±è´¥ï¼å·²é‡è¯• {max_retries} æ¬¡ï¼Œä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                            )
                            self.logger.error(
                                f"é¢„æœŸ: 0 ä¸ªè®¢å•, å®é™…: {open_count} ä¸ªè®¢å•")
                            self.logger.error("âš ï¸ æ­¢ç›ˆé‡ç½®å·²æš‚åœï¼Œä¸ä¼šç»§ç»­åç»­æ­¥éª¤")
                            return  # ç›´æ¥è¿”å›ï¼Œä¸ç»§ç»­æ‰§è¡Œ

                except Exception as e:
                    self.logger.error(f"éªŒè¯è®¢å•çŠ¶æ€å¤±è´¥: {e}")

            # ä»…åœ¨éªŒè¯æˆåŠŸåæ‰ç»§ç»­
            if not cancel_verified:
                self.logger.error("âŒ ç”±äºè®¢å•å–æ¶ˆéªŒè¯å¤±è´¥ï¼Œæ­¢ç›ˆé‡ç½®å·²ä¸­æ­¢")
                return

            # 3. å¹³æ‰æ‰€æœ‰æŒä»“
            self.logger.info("ğŸ“‹ æ­¥éª¤ 3/5: å¹³ä»“...")
            current_position = self.tracker.get_current_position()
            if current_position != 0:
                self.logger.info(f"ğŸ“Š æ­¢ç›ˆå¹³ä»“: {current_position:+.4f}")
                try:
                    # ä½¿ç”¨å¸‚ä»·å•å¹³ä»“
                    side = GridOrderSide.SELL if current_position > 0 else GridOrderSide.BUY
                    await self.engine.place_market_order(
                        side=side,
                        amount=abs(current_position)
                    )
                    self.logger.info("âœ… æ­¢ç›ˆå¹³ä»“å®Œæˆ")
                except Exception as e:
                    self.logger.error(f"âŒ æ­¢ç›ˆå¹³ä»“å¤±è´¥: {e}")
                    # å³ä½¿å¹³ä»“å¤±è´¥ä¹Ÿç»§ç»­é‡ç½®æµç¨‹

            # 4. ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
            await asyncio.sleep(2)

            # 5. é‡æ–°è·å–æŠµæŠ¼å“ä½™é¢ï¼ˆæ­¢ç›ˆåçš„æ–°æœ¬é‡‘ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 4/5: è·å–æ–°æœ¬é‡‘...")
            try:
                await self._update_account_balance()
                new_capital = self._collateral_balance
                self.logger.info(f"ğŸ“Š æ­¢ç›ˆåæ–°æœ¬é‡‘: ${new_capital:,.3f}")
            except Exception as e:
                self.logger.error(f"âš ï¸ è·å–æ­¢ç›ˆåä½™é¢å¤±è´¥: {e}")
                new_capital = self._collateral_balance  # ä½¿ç”¨å½“å‰å€¼

            # 6. é‡ç½®ç½‘æ ¼ï¼ˆä»·æ ¼ç§»åŠ¨ç½‘æ ¼å’Œå›ºå®šèŒƒå›´ç½‘æ ¼éƒ½é‡ç½®ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 5/5: é‡æ–°å¯åŠ¨ç½‘æ ¼...")
            if self.config.is_follow_mode():
                # ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ ¹æ®å½“å‰ä»·æ ¼é‡æ–°æŒ‚å•
                self.logger.info("ğŸ”„ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®å¹¶é‡æ–°å¯åŠ¨...")
                await self._reset_and_restart(new_capital=new_capital)
                self.logger.info("âœ… æ­¢ç›ˆé‡ç½®å®Œæˆï¼Œä»·æ ¼ç§»åŠ¨ç½‘æ ¼å·²é‡å¯")
            else:
                # å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šä¿æŒåŸæœ‰èŒƒå›´é‡æ–°æŒ‚å•
                self.logger.info("ğŸ”„ å›ºå®šèŒƒå›´ç½‘æ ¼ï¼šä¿æŒèŒƒå›´é‡æ–°æŒ‚å•...")
                await self._reset_fixed_range_grid(new_capital=new_capital)
                self.logger.info("âœ… æ­¢ç›ˆé‡ç½®å®Œæˆï¼Œå›ºå®šèŒƒå›´ç½‘æ ¼å·²é‡å¯")

        except Exception as e:
            self.logger.error(f"âŒ æ­¢ç›ˆé‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
        finally:
            # ğŸ”¥ å…³é”®ï¼šæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é‡ç½®é”
            self._resetting = False
            self.logger.info("ğŸ”“ ç³»ç»Ÿé”å®šå·²é‡Šæ”¾")

    async def _reset_and_restart(self, new_capital: Optional[Decimal] = None):
        """é‡ç½®å¹¶é‡æ–°å¯åŠ¨ç½‘æ ¼

        Args:
            new_capital: æ–°çš„åˆå§‹æœ¬é‡‘ï¼ˆæ­¢ç›ˆåä½¿ç”¨ï¼‰
        """
        try:
            self.logger.info("ğŸ”„ é‡ç½®ç½‘æ ¼çŠ¶æ€...")

            # ğŸ”¥ å…³é”®ä¿®å¤ï¼šå…ˆå–æ¶ˆæ‰€æœ‰è®¢å•ï¼ˆé¿å…æ—§è®¢å•ä¸æ–°è®¢å•å†²çªï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 1/7: å–æ¶ˆæ‰€æœ‰è®¢å•...")
            cancelled_count = await self.engine.cancel_all_orders()
            self.logger.info(f"âœ… æ‰¹é‡å–æ¶ˆAPIè¿”å›: {cancelled_count} ä¸ªè®¢å•")

            # ğŸ”¥ éªŒè¯æ‰€æœ‰è®¢å•æ˜¯å¦çœŸçš„è¢«å–æ¶ˆï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 2/7: éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€...")

            max_retries = 3  # æœ€å¤šé‡è¯•3æ¬¡
            retry_delay = 2  # æ¯æ¬¡é‡è¯•é—´éš”2ç§’

            for retry in range(max_retries):
                # ç­‰å¾…è®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
                if retry == 0:
                    await asyncio.sleep(1)  # é¦–æ¬¡éªŒè¯ç­‰å¾…1ç§’
                else:
                    await asyncio.sleep(retry_delay)  # é‡è¯•æ—¶ç­‰å¾…2ç§’

                # è·å–å½“å‰æœªæˆäº¤è®¢å•æ•°é‡
                try:
                    open_orders = await self.engine.exchange.get_open_orders(self.config.symbol)
                    open_count = len(open_orders)

                    if open_count == 0:
                        # éªŒè¯æˆåŠŸ
                        self.logger.info(f"âœ… è®¢å•å–æ¶ˆéªŒè¯é€šè¿‡: å½“å‰æœªæˆäº¤è®¢å• {open_count} ä¸ª")
                        break
                    else:
                        # éªŒè¯å¤±è´¥
                        if retry < max_retries - 1:
                            # è¿˜æœ‰é‡è¯•æœºä¼šï¼Œå°è¯•å†æ¬¡å–æ¶ˆ
                            self.logger.warning(
                                f"âš ï¸ ç¬¬ {retry + 1} æ¬¡éªŒè¯å¤±è´¥: ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                            )
                            self.logger.info(f"ğŸ”„ å°è¯•å†æ¬¡å–æ¶ˆè¿™äº›è®¢å•...")

                            # å†æ¬¡è°ƒç”¨å–æ¶ˆè®¢å•
                            retry_cancelled = await self.engine.cancel_all_orders()
                            self.logger.info(f"é‡è¯•å–æ¶ˆè¿”å›: {retry_cancelled} ä¸ªè®¢å•")
                        else:
                            # å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°
                            self.logger.error(
                                f"âŒ è®¢å•å–æ¶ˆéªŒè¯å¤±è´¥ï¼ˆå·²é‡è¯• {max_retries} æ¬¡ï¼‰: "
                                f"ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                            )
                            self.logger.warning("âš ï¸ ç»§ç»­é‡ç½®æµç¨‹ï¼Œä½†å¯èƒ½ä¼šé‡åˆ°è®¢å•å†²çª...")
                except Exception as e:
                    self.logger.error(f"âš ï¸ éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€æ—¶å‡ºé”™: {e}")
                    if retry == max_retries - 1:
                        self.logger.warning("âš ï¸ æ— æ³•éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€ï¼Œç»§ç»­é‡ç½®æµç¨‹...")
                    break

            self.logger.info("ğŸ“‹ æ­¥éª¤ 3/7: é‡ç½®æ‰€æœ‰ç®¡ç†å™¨çŠ¶æ€...")

            # 1. é‡ç½®æ‰€æœ‰ç®¡ç†å™¨çŠ¶æ€
            if self.scalping_manager:
                self.scalping_manager.reset()
            if self.capital_protection_manager:
                self.capital_protection_manager.reset()
            if self.take_profit_manager:
                self.take_profit_manager.reset()
            if self.price_lock_manager:
                self.price_lock_manager.reset()

            # 2. é‡ç½®è¿½è¸ªå™¨å’ŒçŠ¶æ€
            self.tracker.reset()
            self.state.active_orders.clear()  # æ¸…ç©ºæ‰€æœ‰æ´»è·ƒè®¢å•
            self.state.pending_buy_orders = 0
            self.state.pending_sell_orders = 0

            # 3. ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ›´æ–°ä»·æ ¼åŒºé—´
            self.logger.info("ğŸ“‹ æ­¥éª¤ 4/7: æ›´æ–°ä»·æ ¼åŒºé—´...")
            if self.config.is_follow_mode():
                current_price = await self.engine.get_current_price()
                self.config.update_price_range_for_follow_mode(current_price)
                self.logger.info(
                    f"ğŸ”„ ä»·æ ¼ç§»åŠ¨ç½‘æ ¼ï¼šæ ¹æ®å½“å‰ä»·æ ¼ ${current_price:,.2f} "
                    f"é‡æ–°è®¾ç½®ä»·æ ¼åŒºé—´ [${self.config.lower_price:,.2f}, ${self.config.upper_price:,.2f}]"
                )

            # 4. é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§
            self.logger.info("ğŸ“‹ æ­¥éª¤ 5/7: é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§...")
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )

            # 5. ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•
            self.logger.info("ğŸ“‹ æ­¥éª¤ 6/7: ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•...")
            initial_orders = self.strategy.initialize(self.config)
            self.logger.info(f"ğŸ“‹ ç”Ÿæˆ {len(initial_orders)} ä¸ªåˆå§‹è®¢å•")

            placed_orders = await self.engine.place_batch_orders(initial_orders)
            self.logger.info(f"âœ… æˆåŠŸæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•")

            # ğŸ”¥ å…³é”®ä¿®å¤ï¼šç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œè®©ç«‹å³æˆäº¤çš„è®¢å•å®Œæˆ
            await asyncio.sleep(2)

            # 6. æ·»åŠ åˆ°çŠ¶æ€è¿½è¸ªï¼ˆåªæ·»åŠ æœªæˆäº¤çš„è®¢å•ï¼‰
            self.logger.info("ğŸ“‹ æ­¥éª¤ 7/7: æ·»åŠ è®¢å•åˆ°çŠ¶æ€è¿½è¸ª...")
            # é—®é¢˜ï¼šåœ¨é‡ç½®æœŸé—´æˆäº¤çš„è®¢å•å›è°ƒè¢«è·³è¿‡äº†ï¼Œå¯¼è‡´è¿™äº›è®¢å•çŠ¶æ€ä¸å‡†ç¡®
            # è§£å†³ï¼šæŸ¥è¯¢å¼•æ“è·å–å®é™…çš„æŒ‚å•åˆ—è¡¨ï¼Œåªæ·»åŠ ä»åœ¨æŒ‚å•çš„è®¢å•
            added_count = 0
            skipped_filled = 0
            skipped_exists = 0

            try:
                # è·å–å½“å‰å®é™…æŒ‚å•ï¼ˆä»å¼•æ“ï¼‰
                engine_pending_orders = self.engine.get_pending_orders()
                engine_pending_ids = {
                    order.order_id for order in engine_pending_orders}

                for order in placed_orders:
                    if order.order_id in self.state.active_orders:
                        skipped_exists += 1
                        continue
                    # ğŸ”¥ å…³é”®ï¼šæ£€æŸ¥è®¢å•æ˜¯å¦çœŸçš„è¿˜åœ¨æŒ‚å•ä¸­
                    if order.order_id not in engine_pending_ids:
                        self.logger.debug(f"è®¢å• {order.order_id} å·²æˆäº¤æˆ–å–æ¶ˆï¼Œè·³è¿‡æ·»åŠ ")
                        skipped_filled += 1
                        continue
                    self.state.add_order(order)
                    added_count += 1
            except Exception as e:
                self.logger.warning(f"âš ï¸ æ— æ³•ä»å¼•æ“è·å–æŒ‚å•åˆ—è¡¨ï¼Œä½¿ç”¨è®¢å•çŠ¶æ€åˆ¤æ–­: {e}")
                # Fallbackï¼šä½¿ç”¨è®¢å•è‡ªèº«çš„çŠ¶æ€
                for order in placed_orders:
                    if order.order_id in self.state.active_orders:
                        skipped_exists += 1
                        continue
                    if order.status == GridOrderStatus.FILLED:
                        self.logger.debug(f"è®¢å• {order.order_id} ç«‹å³æˆäº¤ï¼Œè·³è¿‡æ·»åŠ ")
                        skipped_filled += 1
                        continue
                    self.state.add_order(order)
                    added_count += 1

            buy_count = len(
                [o for o in self.state.active_orders.values() if o.side == GridOrderSide.BUY])
            sell_count = len(
                [o for o in self.state.active_orders.values() if o.side == GridOrderSide.SELL])
            self.logger.info(
                f"ğŸ“Š è®¢å•æ·»åŠ è¯¦æƒ…: "
                f"æ–°å¢={added_count}, "
                f"è·³è¿‡(å·²æˆäº¤)={skipped_filled}, "
                f"è·³è¿‡(å·²å­˜åœ¨)={skipped_exists}"
            )
            self.logger.info(
                f"ğŸ“Š çŠ¶æ€ç»Ÿè®¡: "
                f"ä¹°å•={buy_count}, "
                f"å–å•={sell_count}, "
                f"æ´»è·ƒè®¢å•={len(self.state.active_orders)}"
            )

            # 7. é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼ˆæ­¢ç›ˆåï¼‰
            if new_capital is not None:
                if self.capital_protection_manager:
                    self.capital_protection_manager.initialize_capital(
                        new_capital, is_reinit=True)
                if self.take_profit_manager:
                    self.take_profit_manager.initialize_capital(
                        new_capital, is_reinit=True)
                if self.scalping_manager:
                    self.scalping_manager.initialize_capital(
                        new_capital, is_reinit=True)
                self.logger.info(f"ğŸ’° æœ¬é‡‘å·²é‡æ–°åˆå§‹åŒ–: ${new_capital:,.3f}")
            else:
                self.logger.info("â„¹ï¸  æœ¬é‡‘å°†åœ¨å¤–éƒ¨é‡æ–°åˆå§‹åŒ–ï¼ˆä½¿ç”¨æœ€æ–°ä½™é¢ï¼‰")

            self.logger.info("âœ… ç½‘æ ¼é‡ç½®å®Œæˆï¼Œç»§ç»­è¿è¡Œ")

        except Exception as e:
            self.logger.error(f"âŒ ç½‘æ ¼é‡ç½®å¤±è´¥: {e}")
            import traceback
            self.logger.error(f"è¯¦ç»†é”™è¯¯: {traceback.format_exc()}")
            raise

    async def _reset_fixed_range_grid(self, new_capital: Optional[Decimal] = None):
        """é‡ç½®å›ºå®šèŒƒå›´ç½‘æ ¼ï¼ˆä¿æŒåŸæœ‰èŒƒå›´ï¼‰

        Args:
            new_capital: æ–°çš„åˆå§‹æœ¬é‡‘ï¼ˆæ­¢ç›ˆåä½¿ç”¨ï¼‰
        """
        try:
            self.logger.info("ğŸ”„ é‡ç½®å›ºå®šèŒƒå›´ç½‘æ ¼ï¼ˆä¿æŒä»·æ ¼åŒºé—´ï¼‰...")

            # é‡ç½®æ‰€æœ‰ç®¡ç†å™¨çŠ¶æ€
            if self.scalping_manager:
                self.scalping_manager.reset()
            if self.capital_protection_manager:
                self.capital_protection_manager.reset()
            if self.take_profit_manager:
                self.take_profit_manager.reset()

            # é‡ç½®è¿½è¸ªå™¨å’ŒçŠ¶æ€
            self.tracker.reset()
            self.state.active_orders.clear()  # æ¸…ç©ºæ‰€æœ‰æ´»è·ƒè®¢å•
            self.state.pending_buy_orders = 0
            self.state.pending_sell_orders = 0

            # é‡æ–°åˆå§‹åŒ–ç½‘æ ¼å±‚çº§ï¼ˆä¿æŒåŸæœ‰ä»·æ ¼åŒºé—´ï¼‰
            self.state.initialize_grid_levels(
                self.config.grid_count,
                self.config.get_grid_price
            )

            # ç”Ÿæˆå¹¶æŒ‚å‡ºæ–°è®¢å•ï¼ˆä½¿ç”¨åŸæœ‰ä»·æ ¼èŒƒå›´ï¼‰
            self.logger.info(
                f"ğŸš€ é‡æ–°åˆå§‹åŒ–å›ºå®šèŒƒå›´ç½‘æ ¼å¹¶æŒ‚å•: "
                f"${self.config.lower_price:,.2f} - ${self.config.upper_price:,.2f}"
            )
            initial_orders = self.strategy.initialize(self.config)
            self.logger.info(f"ğŸ“‹ ç”Ÿæˆ {len(initial_orders)} ä¸ªåˆå§‹è®¢å•")

            placed_orders = await self.engine.place_batch_orders(initial_orders)
            self.logger.info(f"âœ… æˆåŠŸæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•")

            # ğŸ”¥ å…³é”®ä¿®å¤ï¼šç­‰å¾…WebSocketå¤„ç†ç«‹å³æˆäº¤çš„è®¢å•
            await asyncio.sleep(2)

            # æ·»åŠ åˆ°çŠ¶æ€è¿½è¸ªï¼ˆåªæ·»åŠ æœªæˆäº¤çš„è®¢å•ï¼‰
            added_count = 0
            skipped_filled = 0
            skipped_exists = 0

            try:
                # è·å–å½“å‰å®é™…æŒ‚å•ï¼ˆä»å¼•æ“ï¼‰
                engine_pending_orders = self.engine.get_pending_orders()
                engine_pending_ids = {
                    order.order_id for order in engine_pending_orders}

                for order in placed_orders:
                    if order.order_id in self.state.active_orders:
                        skipped_exists += 1
                        continue
                    # ğŸ”¥ å…³é”®ï¼šæ£€æŸ¥è®¢å•æ˜¯å¦çœŸçš„è¿˜åœ¨æŒ‚å•ä¸­
                    if order.order_id not in engine_pending_ids:
                        self.logger.debug(f"è®¢å• {order.order_id} å·²æˆäº¤æˆ–å–æ¶ˆï¼Œè·³è¿‡æ·»åŠ ")
                        skipped_filled += 1
                        continue
                    self.state.add_order(order)
                    added_count += 1
            except Exception as e:
                self.logger.warning(f"âš ï¸ æ— æ³•ä»å¼•æ“è·å–æŒ‚å•åˆ—è¡¨ï¼Œä½¿ç”¨è®¢å•çŠ¶æ€åˆ¤æ–­: {e}")
                # Fallbackï¼šä½¿ç”¨è®¢å•è‡ªèº«çš„çŠ¶æ€
                for order in placed_orders:
                    if order.order_id in self.state.active_orders:
                        skipped_exists += 1
                        continue
                    if order.status == GridOrderStatus.FILLED:
                        self.logger.debug(f"è®¢å• {order.order_id} ç«‹å³æˆäº¤ï¼Œè·³è¿‡æ·»åŠ ")
                        skipped_filled += 1
                        continue
                    self.state.add_order(order)
                    added_count += 1

            buy_count = len(
                [o for o in self.state.active_orders.values() if o.side == GridOrderSide.BUY])
            sell_count = len(
                [o for o in self.state.active_orders.values() if o.side == GridOrderSide.SELL])
            self.logger.info(
                f"ğŸ“Š è®¢å•æ·»åŠ è¯¦æƒ…: "
                f"æ–°å¢={added_count}, "
                f"è·³è¿‡(å·²æˆäº¤)={skipped_filled}, "
                f"è·³è¿‡(å·²å­˜åœ¨)={skipped_exists}"
            )
            self.logger.info(
                f"ğŸ“Š çŠ¶æ€ç»Ÿè®¡: "
                f"ä¹°å•={buy_count}, "
                f"å–å•={sell_count}, "
                f"æ´»è·ƒè®¢å•={len(self.state.active_orders)}"
            )

            # ğŸ”¥ é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼ˆæ­¢ç›ˆåï¼‰
            if new_capital is not None:
                if self.capital_protection_manager:
                    self.capital_protection_manager.initialize_capital(
                        new_capital, is_reinit=True)
                if self.take_profit_manager:
                    self.take_profit_manager.initialize_capital(
                        new_capital, is_reinit=True)
                if self.scalping_manager:
                    self.scalping_manager.initialize_capital(
                        new_capital, is_reinit=True)
                self.logger.info(f"ğŸ’° æœ¬é‡‘å·²é‡æ–°åˆå§‹åŒ–: ${new_capital:,.3f}")

            self.logger.info("âœ… å›ºå®šèŒƒå›´ç½‘æ ¼é‡ç½®å®Œæˆï¼Œç»§ç»­è¿è¡Œ")

        except Exception as e:
            self.logger.error(f"âŒ å›ºå®šèŒƒå›´ç½‘æ ¼é‡ç½®å¤±è´¥: {e}")
            raise

    async def _activate_scalping_mode(self):
        """æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼ï¼ˆä¸²è¡ŒéªŒè¯ç‰ˆï¼‰"""
        self.logger.warning("ğŸ”´ æ­£åœ¨æ¿€æ´»å‰¥å¤´çš®æ¨¡å¼...")

        # 1. æ¿€æ´»å‰¥å¤´çš®ç®¡ç†å™¨
        self.scalping_manager.activate()

        # 2. ğŸ”¥ å–æ¶ˆæ‰€æœ‰å–å•ï¼ˆå¸¦éªŒè¯ï¼‰- ä½¿ç”¨æ–°çš„éªŒè¯æ–¹æ³•
        if not await self._cancel_all_sell_orders_with_verification(max_attempts=3):
            self.logger.error("âŒ å–æ¶ˆå–å•å¤±è´¥ï¼Œå‰¥å¤´çš®æ¿€æ´»ä¸­æ­¢")
            self.scalping_manager.deactivate()
            return

        # 3. ğŸ”¥ æ··åˆç­–ç•¥è·å–å®æ—¶æŒä»“ï¼šWebSocketä¼˜å…ˆï¼ŒREST APIå¤‡ç”¨
        self.logger.info("ğŸ“Š æ­£åœ¨è·å–å®æ—¶æŒä»“ä¿¡æ¯ï¼ˆWebSocketä¼˜å…ˆï¼ŒREST APIå¤‡ç”¨ï¼‰...")

        # ç¬¬ä¸€æ­¥ï¼šå°è¯•ä»WebSocketç¼“å­˜è·å–
        position_data = await self.engine.get_real_time_position(self.config.symbol)
        current_position = position_data['size']
        average_cost = position_data['entry_price']
        data_source = "WebSocket"

        # ç¬¬äºŒæ­¥ï¼šå¦‚æœWebSocketç¼“å­˜ä¸ºç©ºï¼Œä½¿ç”¨REST APIä½œä¸ºå¤‡ç”¨
        if current_position == 0 and average_cost == 0:
            self.logger.warning(
                "âš ï¸ WebSocketæŒä»“ç¼“å­˜ä¸ºç©ºï¼ˆäº¤æ˜“æ‰€æœªæ¨é€åˆå§‹æŒä»“ï¼‰ï¼Œ"
                "ä½¿ç”¨REST APIè·å–å‡†ç¡®æ•°æ®..."
            )

            try:
                # è°ƒç”¨REST APIè·å–æŒä»“ï¼ˆå‡†ç¡®ä½†æœ‰å»¶è¿Ÿï¼‰
                positions = await self.engine.exchange.get_positions(
                    symbols=[self.config.symbol]
                )

                if positions and len(positions) > 0:
                    position = positions[0]
                    current_position = position.size or Decimal('0')
                    average_cost = position.entry_price or Decimal('0')

                    # æ ¹æ®æ–¹å‘ç¡®å®šæŒä»“ç¬¦å·
                    if hasattr(position, 'side'):
                        from ....adapters.exchanges import PositionSide
                        if position.side == PositionSide.SHORT and current_position != 0:
                            current_position = -current_position

                    data_source = "REST API"

                    # åŒæ­¥åˆ°WebSocketç¼“å­˜ï¼ˆä¾›åç»­ä½¿ç”¨ï¼‰
                    if not hasattr(self.engine.exchange, '_position_cache'):
                        self.engine.exchange._position_cache = {}
                    self.engine.exchange._position_cache[self.config.symbol] = {
                        'size': current_position,
                        'entry_price': average_cost,
                        'unrealized_pnl': position.unrealized_pnl or Decimal('0'),
                        'side': 'Long' if current_position > 0 else 'Short',
                        'timestamp': datetime.now()
                    }

                    self.logger.info(
                        f"âœ… REST APIè·å–æˆåŠŸ: {current_position} {self.config.symbol.split('_')[0]}, "
                        f"æˆæœ¬=${average_cost:,.2f}ï¼Œå·²åŒæ­¥åˆ°WebSocketç¼“å­˜"
                    )
                else:
                    self.logger.warning("âš ï¸ REST APIè¿”å›ç©ºæŒä»“")

            except Exception as e:
                self.logger.error(f"âŒ REST APIè·å–æŒä»“å¤±è´¥: {e}")
                import traceback
                self.logger.error(traceback.format_exc())

        self.logger.info(
            f"ğŸ“Š æœ€ç»ˆæŒä»“ï¼ˆæ¥æº: {data_source}ï¼‰: "
            f"{current_position} {self.config.symbol.split('_')[0]}, "
            f"å¹³å‡æˆæœ¬: ${average_cost:,.2f}"
        )

        initial_capital = self.scalping_manager.get_initial_capital()
        self.scalping_manager.update_position(
            current_position, average_cost, initial_capital, self._collateral_balance)
        self._last_ws_position_size = current_position
        self._last_ws_position_price = average_cost

        # 4. ğŸ”¥ æŒ‚æ­¢ç›ˆè®¢å•ï¼ˆå¸¦éªŒè¯ï¼‰
        if not await self._place_take_profit_order_with_verification(max_attempts=3):
            self.logger.error("âŒ æŒ‚æ­¢ç›ˆè®¢å•å¤±è´¥ï¼Œä½†å‰¥å¤´çš®æ¨¡å¼å·²æ¿€æ´»")
            # ä¸ä¸­æ­¢æµç¨‹ï¼Œç»§ç»­è¿è¡Œ

        # 5. ğŸ”¥ æ³¨å†ŒWebSocketæŒä»“æ›´æ–°å›è°ƒï¼ˆäº‹ä»¶é©±åŠ¨ï¼Œä¸å†è½®è¯¢ï¼‰
        if not hasattr(self.engine.exchange, '_position_callbacks'):
            self.engine.exchange._position_callbacks = []
        if self._on_position_update_from_ws not in self.engine.exchange._position_callbacks:
            self.engine.exchange._position_callbacks.append(
                self._on_position_update_from_ws)
            self.logger.info("âœ… å·²æ³¨å†ŒWebSocketæŒä»“æ›´æ–°å›è°ƒï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰")

        self.logger.warning("âœ… å‰¥å¤´çš®æ¨¡å¼å·²æ¿€æ´»")

    async def _deactivate_scalping_mode(self):
        """é€€å‡ºå‰¥å¤´çš®æ¨¡å¼ï¼Œæ¢å¤æ­£å¸¸ç½‘æ ¼"""
        self.logger.info("ğŸŸ¢ æ­£åœ¨é€€å‡ºå‰¥å¤´çš®æ¨¡å¼...")

        # 1. ğŸ”¥ ç§»é™¤WebSocketæŒä»“æ›´æ–°å›è°ƒ
        if hasattr(self.engine.exchange, '_position_callbacks'):
            if self._on_position_update_from_ws in self.engine.exchange._position_callbacks:
                self.engine.exchange._position_callbacks.remove(
                    self._on_position_update_from_ws)
                self.logger.info("âœ… å·²ç§»é™¤WebSocketæŒä»“æ›´æ–°å›è°ƒ")

        # 2. åœç”¨å‰¥å¤´çš®ç®¡ç†å™¨ï¼ˆå…ˆåœç”¨ï¼Œé¿å…å¹²æ‰°ï¼‰
        self.scalping_manager.deactivate()

        # 3. å–æ¶ˆæ‰€æœ‰è®¢å•ï¼ˆåŒ…æ‹¬æ­¢ç›ˆè®¢å•å’Œåå‘è®¢å•ï¼‰
        self.logger.info("ğŸ“‹ æ­¥éª¤ 1/3: å–æ¶ˆæ‰€æœ‰è®¢å•...")
        try:
            cancelled_count = await self.engine.cancel_all_orders()
            self.logger.info(f"âœ… æ‰¹é‡å–æ¶ˆAPIè¿”å›: {cancelled_count} ä¸ªè®¢å•")
        except Exception as e:
            self.logger.error(f"âŒ æ‰¹é‡å–æ¶ˆè®¢å•å¤±è´¥: {e}")

        # 4. éªŒè¯æ‰€æœ‰è®¢å•æ˜¯å¦çœŸçš„è¢«å–æ¶ˆï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
        self.logger.info("ğŸ“‹ æ­¥éª¤ 2/3: éªŒè¯è®¢å•å–æ¶ˆçŠ¶æ€...")

        max_retries = 3  # æœ€å¤šé‡è¯•3æ¬¡
        retry_delay = 1.5  # æ¯æ¬¡é‡è¯•é—´éš”1.5ç§’
        cancel_verified = False

        for retry in range(max_retries):
            # ç­‰å¾…è®©äº¤æ˜“æ‰€å¤„ç†å–æ¶ˆè¯·æ±‚
            if retry == 0:
                await asyncio.sleep(0.8)  # é¦–æ¬¡éªŒè¯ç­‰å¾…0.8ç§’
            else:
                await asyncio.sleep(retry_delay)  # é‡è¯•æ—¶ç­‰å¾…1.5ç§’

            # è·å–å½“å‰æœªæˆäº¤è®¢å•
            try:
                open_orders = await self.engine.exchange.get_open_orders(self.config.symbol)
                open_count = len(open_orders)

                if open_count == 0:
                    # éªŒè¯æˆåŠŸ
                    self.logger.info(f"âœ… è®¢å•å–æ¶ˆéªŒè¯é€šè¿‡: å½“å‰æœªæˆäº¤è®¢å• {open_count} ä¸ª")
                    cancel_verified = True
                    break
                else:
                    # éªŒè¯å¤±è´¥
                    if retry < max_retries - 1:
                        # è¿˜æœ‰é‡è¯•æœºä¼šï¼Œå°è¯•å†æ¬¡å–æ¶ˆ
                        self.logger.warning(
                            f"âš ï¸ ç¬¬ {retry + 1} æ¬¡éªŒè¯å¤±è´¥: ä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                        )
                        self.logger.info(f"ğŸ”„ å°è¯•å†æ¬¡å–æ¶ˆè¿™äº›è®¢å•...")

                        # å†æ¬¡è°ƒç”¨å–æ¶ˆè®¢å•
                        try:
                            retry_cancelled = await self.engine.cancel_all_orders()
                            self.logger.info(f"é‡è¯•å–æ¶ˆè¿”å›: {retry_cancelled} ä¸ªè®¢å•")
                        except Exception as e:
                            self.logger.error(f"é‡è¯•å–æ¶ˆå¤±è´¥: {e}")
                    else:
                        # å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
                        self.logger.error(
                            f"âŒ è®¢å•å–æ¶ˆéªŒè¯æœ€ç»ˆå¤±è´¥ï¼å·²é‡è¯• {max_retries} æ¬¡ï¼Œä»æœ‰ {open_count} ä¸ªæœªæˆäº¤è®¢å•"
                        )
                        self.logger.error(f"é¢„æœŸ: 0 ä¸ªè®¢å•, å®é™…: {open_count} ä¸ªè®¢å•")
                        self.logger.error("âš ï¸ æ¢å¤æ­£å¸¸ç½‘æ ¼å·²æš‚åœï¼Œä¸ä¼šæŒ‚å‡ºæ–°è®¢å•ï¼Œé¿å…è¶…å‡ºè®¢å•é™åˆ¶")
                        self.logger.error("ğŸ’¡ å»ºè®®: è¯·æ‰‹åŠ¨æ£€æŸ¥äº¤æ˜“æ‰€è®¢å•")

            except Exception as e:
                self.logger.error(f"éªŒè¯è®¢å•çŠ¶æ€å¤±è´¥: {e}")

        # 5. ä»…åœ¨éªŒè¯æˆåŠŸåæ‰æ¢å¤æ­£å¸¸ç½‘æ ¼
        if cancel_verified:
            self.logger.info("ğŸ“‹ æ­¥éª¤ 3/3: æ¢å¤æ­£å¸¸ç½‘æ ¼æ¨¡å¼ï¼Œé‡æ–°æŒ‚å•...")

            try:
                # é‡æ–°ç”Ÿæˆæ‰€æœ‰ç½‘æ ¼è®¢å•
                initial_orders = self.strategy.initialize(self.config)

                # æ‰¹é‡æŒ‚å•
                placed_orders = await self.engine.place_batch_orders(initial_orders)

                # æ›´æ–°çŠ¶æ€
                for order in placed_orders:
                    if order.order_id not in self.state.active_orders:
                        self.state.add_order(order)

                self.logger.info(f"âœ… å·²æ¢å¤æ­£å¸¸ç½‘æ ¼ï¼ŒæŒ‚å‡º {len(placed_orders)} ä¸ªè®¢å•")

            except Exception as e:
                self.logger.error(f"âŒ æ¢å¤æ­£å¸¸ç½‘æ ¼å¤±è´¥: {e}")
        else:
            self.logger.error("âŒ ç”±äºè®¢å•å–æ¶ˆéªŒè¯å¤±è´¥ï¼Œè·³è¿‡æ¢å¤æ­£å¸¸ç½‘æ ¼æ­¥éª¤")
            self.logger.error("ğŸ’¡ å‰¥å¤´çš®æ¨¡å¼å·²åœç”¨ï¼Œä½†ç½‘æ ¼æœªæ¢å¤ï¼Œç³»ç»Ÿå¤„äºæš‚åœçŠ¶æ€")

    async def _place_take_profit_order(self):
        """æŒ‚æ­¢ç›ˆè®¢å•"""
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return

        # è·å–å½“å‰ä»·æ ¼
        current_price = await self.engine.get_current_price()

        # è®¡ç®—æ­¢ç›ˆè®¢å•
        tp_order = self.scalping_manager.calculate_take_profit_order(
            current_price)

        if not tp_order:
            self.logger.info("ğŸ“‹ å½“å‰æ— æŒä»“ï¼Œä¸æŒ‚æ­¢ç›ˆè®¢å•")
            return

        try:
            # ä¸‹æ­¢ç›ˆè®¢å•
            placed_order = await self.engine.place_order(tp_order)
            self.state.add_order(placed_order)

            self.logger.info(
                f"ğŸ’° æ­¢ç›ˆè®¢å•å·²æŒ‚: {placed_order.side.value} "
                f"{placed_order.amount}@{placed_order.price} "
                f"(Grid {placed_order.grid_id})"
            )
        except Exception as e:
            self.logger.error(f"âŒ æŒ‚æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")

    async def _place_take_profit_order_with_verification(self, max_attempts: int = 3) -> bool:
        """
        æŒ‚æ­¢ç›ˆè®¢å•ï¼Œå¹¶éªŒè¯æˆåŠŸ

        å¾ªç¯é€»è¾‘ï¼š
        1. æŒ‚æ­¢ç›ˆè®¢å•
        2. ä»äº¤æ˜“æ‰€éªŒè¯è®¢å•å·²æŒ‚å‡º
        3. å¦‚æœæœªæŒ‚å‡ºï¼Œé‡æ–°æŒ‚
        4. é‡å¤æœ€å¤šmax_attemptsæ¬¡

        Args:
            max_attempts: æœ€å¤§å°è¯•æ¬¡æ•°

        Returns:
            True: æ­¢ç›ˆè®¢å•å·²æŒ‚å‡º
            False: æŒ‚å•å¤±è´¥
        """
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return False

        for attempt in range(max_attempts):
            self.logger.info(
                f"ğŸ”„ æŒ‚æ­¢ç›ˆè®¢å•å°è¯• {attempt+1}/{max_attempts}..."
            )

            # 1. è·å–å½“å‰ä»·æ ¼
            try:
                current_price = await self.engine.get_current_price()
            except Exception as e:
                self.logger.error(f"è·å–å½“å‰ä»·æ ¼å¤±è´¥: {e}")
                if attempt < max_attempts - 1:
                    await asyncio.sleep(0.5)
                continue

            # 2. è®¡ç®—æ­¢ç›ˆè®¢å•
            tp_order = self.scalping_manager.calculate_take_profit_order(
                current_price)

            if not tp_order:
                self.logger.info("ğŸ“‹ å½“å‰æ— æŒä»“ï¼Œæ— éœ€æŒ‚æ­¢ç›ˆè®¢å•")
                return True  # æ— æŒä»“è§†ä¸ºæˆåŠŸ

            # 3. æŒ‚æ­¢ç›ˆè®¢å•
            try:
                placed_order = await self.engine.place_order(tp_order)
                self.state.add_order(placed_order)

                self.logger.info(
                    f"ğŸ’° æ­¢ç›ˆè®¢å•å·²æäº¤: {placed_order.side.value} "
                    f"{placed_order.amount}@${placed_order.price} "
                    f"(Grid {placed_order.grid_id})"
                )

                # 4. ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©äº¤æ˜“æ‰€å¤„ç†æŒ‚å•è¯·æ±‚
                await asyncio.sleep(0.3)

                # 5. ğŸ”¥ å…³é”®ï¼šä»äº¤æ˜“æ‰€éªŒè¯è®¢å•å·²æŒ‚å‡º
                if await self._verify_take_profit_order_placed(placed_order.order_id):
                    self.logger.info(f"âœ… æ­¢ç›ˆè®¢å•æŒ‚å‡ºæˆåŠŸï¼ˆå°è¯•{attempt+1}æ¬¡ï¼‰")
                    return True
                else:
                    self.logger.warning(
                        f"âš ï¸ æ­¢ç›ˆè®¢å•æœªåœ¨äº¤æ˜“æ‰€æ‰¾åˆ°ï¼Œå‡†å¤‡ç¬¬{attempt+2}æ¬¡å°è¯•..."
                    )
                    # ä»æœ¬åœ°çŠ¶æ€ç§»é™¤ï¼Œå‡†å¤‡é‡è¯•
                    self.state.remove_order(placed_order.order_id)

            except Exception as e:
                self.logger.error(f"æŒ‚æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")
                if attempt < max_attempts - 1:
                    await asyncio.sleep(0.5)

        # è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ï¼ŒæŒ‚å•ä»å¤±è´¥
        self.logger.error(
            f"âŒ æŒ‚æ­¢ç›ˆè®¢å•å¤±è´¥: å·²å°è¯•{max_attempts}æ¬¡"
        )
        return False

    async def _update_take_profit_order_if_needed(self):
        """å¦‚æœæŒä»“å˜åŒ–ï¼Œæ›´æ–°æ­¢ç›ˆè®¢å•ï¼ˆå¸¦éªŒè¯ï¼‰"""
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return

        current_position = self.tracker.get_current_position()

        # æ£€æŸ¥æ­¢ç›ˆè®¢å•æ˜¯å¦éœ€è¦æ›´æ–°
        if not self.scalping_manager.is_take_profit_order_outdated(current_position):
            return

        self.logger.info("ğŸ“‹ æŒä»“å˜åŒ–ï¼Œæ›´æ–°æ­¢ç›ˆè®¢å•...")

        # ğŸ”¥ 1. å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•ï¼ˆå¸¦éªŒè¯ï¼‰
        old_tp_order = self.scalping_manager.get_current_take_profit_order()
        if old_tp_order:
            max_cancel_attempts = 3
            cancel_success = False

            for attempt in range(max_cancel_attempts):
                try:
                    await self.engine.cancel_order(old_tp_order.order_id)
                    self.state.remove_order(old_tp_order.order_id)
                    self.logger.info(f"âœ… å·²å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•: {old_tp_order.order_id}")

                    # ç­‰å¾…å–æ¶ˆå®Œæˆ
                    await asyncio.sleep(0.3)

                    # ğŸ”¥ éªŒè¯è®¢å•å·²å–æ¶ˆï¼ˆä»äº¤æ˜“æ‰€æŸ¥è¯¢ï¼‰
                    try:
                        exchange_orders = await self.engine.exchange.get_open_orders(
                            symbol=self.config.symbol
                        )
                        found = any(
                            order.order_id == old_tp_order.order_id
                            for order in exchange_orders
                        )

                        if not found:
                            self.logger.info("âœ… éªŒè¯é€šè¿‡: æ—§æ­¢ç›ˆè®¢å•å·²å–æ¶ˆ")
                            cancel_success = True
                            break
                        else:
                            self.logger.warning(
                                f"âš ï¸ éªŒè¯å¤±è´¥ (å°è¯•{attempt+1}/{max_cancel_attempts}): "
                                f"è®¢å•ä»å­˜åœ¨ï¼Œé‡æ–°å–æ¶ˆ..."
                            )

                    except Exception as e:
                        self.logger.error(f"éªŒè¯å–æ¶ˆå¤±è´¥: {e}")

                except Exception as e:
                    error_msg = str(e).lower()
                    if "not found" in error_msg or "does not exist" in error_msg:
                        self.logger.info("è®¢å•å·²ä¸å­˜åœ¨ï¼Œè§†ä¸ºå–æ¶ˆæˆåŠŸ")
                        cancel_success = True
                        break
                    else:
                        self.logger.error(f"å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•å¤±è´¥: {e}")

            if not cancel_success:
                self.logger.error("âŒ å–æ¶ˆæ—§æ­¢ç›ˆè®¢å•å¤±è´¥ï¼Œä¸­æ­¢æ›´æ–°")
                return

        # ğŸ”¥ 2. æŒ‚æ–°æ­¢ç›ˆè®¢å•ï¼ˆå¸¦éªŒè¯ï¼‰
        if not await self._place_take_profit_order_with_verification(max_attempts=3):
            self.logger.error("âŒ æŒ‚æ–°æ­¢ç›ˆè®¢å•å¤±è´¥")
        else:
            self.logger.info("âœ… æ­¢ç›ˆè®¢å•å·²æ›´æ–°")

    def _is_take_profit_order_filled(self, filled_order: GridOrder) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ˜¯æ­¢ç›ˆè®¢å•æˆäº¤"""
        if not self.scalping_manager or not self.scalping_manager.is_active():
            return False

        tp_order = self.scalping_manager.get_current_take_profit_order()
        if not tp_order:
            return False

        return filled_order.order_id == tp_order.order_id

    async def _handle_take_profit_filled(self):
        """å¤„ç†å‰¥å¤´çš®æ­¢ç›ˆè®¢å•æˆäº¤ï¼ˆæŒä»“å·²å¹³ä»“ï¼Œéœ€è¦é‡ç½®ç½‘æ ¼å¹¶é‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰"""
        try:
            # ğŸ”¥ å…³é”®ï¼šè®¾ç½®é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢å¹¶å‘æ“ä½œ
            self._resetting = True
            self.logger.warning("ğŸ¯ å‰¥å¤´çš®æ­¢ç›ˆè®¢å•å·²æˆäº¤ï¼ï¼ˆé”å®šç³»ç»Ÿï¼‰")

            # ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å¹³ä»“å®Œæˆå¹¶ä½™é¢æ›´æ–°
            await asyncio.sleep(2)

            # æ ¹æ®ç½‘æ ¼ç±»å‹å†³å®šåç»­è¡Œä¸º
            if self.config.is_follow_mode():
                # è·Ÿéšç§»åŠ¨ç½‘æ ¼ï¼šé‡ç½®å¹¶é‡å¯ï¼ˆé‡æ–°åˆå§‹åŒ–æœ¬é‡‘ï¼‰
                self.logger.info("ğŸ”„ è·Ÿéšç§»åŠ¨ç½‘æ ¼æ¨¡å¼ï¼šå‡†å¤‡é‡ç½®å¹¶é‡å¯...")

                # ğŸ”¥ ä¿®å¤ï¼šåœ¨é‡ç½®åå†è·å–æœ€æ–°ä½™é¢ä½œä¸ºæ–°æœ¬é‡‘
                # ä¸åœ¨é‡ç½®å‰è·å–ï¼Œå› ä¸ºé‡ç½®è¿‡ç¨‹ä¸­ä½™é¢å¯èƒ½ä¼šå˜åŒ–
                await self._reset_and_restart(new_capital=None)

                # é‡ç½®å®Œæˆåï¼Œè·å–æœ€æ–°ä½™é¢ä½œä¸ºæ–°æœ¬é‡‘
                try:
                    await self._update_account_balance()
                    new_capital = self._collateral_balance
                    self.logger.info(f"ğŸ“Š é‡ç½®åæœ€æ–°æœ¬é‡‘: ${new_capital:,.3f}")

                    # é‡æ–°åˆå§‹åŒ–æ‰€æœ‰ç®¡ç†å™¨çš„æœ¬é‡‘
                    if self.capital_protection_manager:
                        self.capital_protection_manager.initialize_capital(
                            new_capital, is_reinit=True)
                    if self.take_profit_manager:
                        self.take_profit_manager.initialize_capital(
                            new_capital, is_reinit=True)
                    if self.scalping_manager:
                        self.scalping_manager.initialize_capital(
                            new_capital, is_reinit=True)

                    self.logger.info(f"ğŸ’° æ‰€æœ‰ç®¡ç†å™¨æœ¬é‡‘å·²æ›´æ–°ä¸ºæœ€æ–°ä½™é¢: ${new_capital:,.3f}")
                except Exception as e:
                    self.logger.error(f"âš ï¸ è·å–æœ€æ–°ä½™é¢å¤±è´¥: {e}")

                self.logger.info("âœ… å‰¥å¤´çš®é‡ç½®å®Œæˆï¼Œä»·æ ¼ç§»åŠ¨ç½‘æ ¼å·²é‡å¯")
            else:
                # æ™®é€š/é©¬ä¸ç½‘æ ¼ï¼šåœæ­¢ç³»ç»Ÿ
                self.logger.info("â¸ï¸  æ™®é€š/é©¬ä¸ç½‘æ ¼æ¨¡å¼ï¼šåœæ­¢ç³»ç»Ÿ")
                await self.stop()
        finally:
            # ğŸ”¥ å…³é”®ï¼šæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é‡ç½®é”
            self._resetting = False
            self.logger.info("ğŸ”“ ç³»ç»Ÿé”å®šå·²é‡Šæ”¾")

    def _should_place_reverse_order_in_scalping(self, filled_order: GridOrder) -> bool:
        """
        åˆ¤æ–­åœ¨å‰¥å¤´çš®æ¨¡å¼ä¸‹æ˜¯å¦åº”è¯¥æŒ‚åå‘è®¢å•

        Args:
            filled_order: å·²æˆäº¤è®¢å•

        Returns:
            æ˜¯å¦åº”è¯¥æŒ‚åå‘è®¢å•
        """
        from ..models import GridType

        # åšå¤šç½‘æ ¼ï¼šåªæŒ‚ä¹°å•ï¼ˆå»ºä»“ï¼‰ï¼Œä¸æŒ‚å–å•ï¼ˆå¹³ä»“ï¼‰
        if self.config.grid_type in [GridType.LONG, GridType.FOLLOW_LONG, GridType.MARTINGALE_LONG]:
            # å¦‚æœæˆäº¤çš„æ˜¯ä¹°å•ï¼Œåº”è¯¥æŒ‚å–å•ï¼Œä½†å‰¥å¤´çš®æ¨¡å¼ä¸æŒ‚
            return filled_order.side == GridOrderSide.SELL

        # åšç©ºç½‘æ ¼ï¼šåªæŒ‚å–å•ï¼ˆå»ºä»“ï¼‰ï¼Œä¸æŒ‚ä¹°å•ï¼ˆå¹³ä»“ï¼‰
        else:
            # å¦‚æœæˆäº¤çš„æ˜¯å–å•ï¼Œåº”è¯¥æŒ‚ä¹°å•ï¼Œä½†å‰¥å¤´çš®æ¨¡å¼ä¸æŒ‚
            return filled_order.side == GridOrderSide.BUY

    def _sync_orders_from_engine(self):
        """
        ä»engineåŒæ­¥æœ€æ–°çš„è®¢å•ç»Ÿè®¡åˆ°state

        å¥åº·æ£€æŸ¥åï¼Œengineçš„_pending_orderså¯èƒ½å·²æ›´æ–°ï¼Œéœ€è¦åŒæ­¥åˆ°state
        è¿™æ ·UIæ‰èƒ½æ˜¾ç¤ºæ­£ç¡®çš„è®¢å•æ•°é‡

        ğŸ”¥ ä¿®å¤ï¼šåŒæ—¶åŒæ­¥state.active_ordersï¼Œç¡®ä¿è®¢å•æˆäº¤æ—¶èƒ½æ­£ç¡®æ›´æ–°ç»Ÿè®¡
        """
        try:
            # ä»engineè·å–å½“å‰æŒ‚å•
            engine_orders = self.engine.get_pending_orders()

            # ç»Ÿè®¡ä¹°å•å’Œå–å•æ•°é‡
            buy_count = sum(
                1 for order in engine_orders if order.side == GridOrderSide.BUY)
            sell_count = sum(
                1 for order in engine_orders if order.side == GridOrderSide.SELL)

            # æ›´æ–°stateçš„ç»Ÿè®¡æ•°æ®
            self.state.pending_buy_orders = buy_count
            self.state.pending_sell_orders = sell_count

            # ğŸ”¥ æ–°å¢ï¼šåŒæ­¥state.active_orders
            # ç¡®ä¿state.active_ordersåŒ…å«æ‰€æœ‰engineä¸­çš„è®¢å•
            engine_order_ids = {order.order_id for order in engine_orders}
            state_order_ids = set(self.state.active_orders.keys())

            # 1. ç§»é™¤stateä¸­å·²ä¸å­˜åœ¨äºengineçš„è®¢å•
            removed_orders = state_order_ids - engine_order_ids
            for order_id in removed_orders:
                if order_id in self.state.active_orders:
                    del self.state.active_orders[order_id]

            # 2. æ·»åŠ engineä¸­å­˜åœ¨ä½†stateä¸­æ²¡æœ‰çš„è®¢å•ï¼ˆå¥åº·æ£€æŸ¥æ–°å¢çš„ï¼‰
            added_orders = engine_order_ids - state_order_ids
            for order in engine_orders:
                if order.order_id in added_orders:
                    # æ·»åŠ åˆ°state.active_ordersï¼Œè¿™æ ·æˆäº¤æ—¶èƒ½æ­£ç¡®æ›´æ–°ç»Ÿè®¡
                    self.state.active_orders[order.order_id] = order

            # è®°å½•åŒæ­¥ä¿¡æ¯
            if removed_orders or added_orders:
                self.logger.debug(
                    f"ğŸ“Š è®¢å•åŒæ­¥: Stateå¢åŠ {len(added_orders)}ä¸ª, ç§»é™¤{len(removed_orders)}ä¸ª, "
                    f"å½“å‰={len(self.state.active_orders)}ä¸ª"
                )

            # å¦‚æœengineå’Œstateçš„è®¢å•æ•°é‡å·®å¼‚è¾ƒå¤§ï¼Œè®°å½•æ—¥å¿—
            state_total = len(self.state.active_orders)
            engine_total = len(engine_orders)

            if abs(state_total - engine_total) > 5:
                self.logger.warning(
                    f"âš ï¸ è®¢å•åŒæ­¥åä»æœ‰å·®å¼‚: State={state_total}ä¸ª, Engine={engine_total}ä¸ª, "
                    f"å·®å¼‚={abs(state_total - engine_total)}ä¸ª"
                )

        except Exception as e:
            self.logger.debug(f"åŒæ­¥è®¢å•ç»Ÿè®¡å¤±è´¥: {e}")

    async def _balance_monitor_loop(self):
        """
        è´¦æˆ·ä½™é¢ç›‘æ§å¾ªç¯

        å®šæœŸè°ƒç”¨REST APIæŸ¥è¯¢è´¦æˆ·ä½™é¢ï¼ˆUSDCï¼‰
        """
        self.logger.info("ğŸ’° è´¦æˆ·ä½™é¢ç›‘æ§å¾ªç¯å·²å¯åŠ¨")

        while self._running:
            try:
                await self._update_account_balance()
                await asyncio.sleep(self._balance_update_interval)
            except asyncio.CancelledError:
                self.logger.info("ğŸ’° ä½™é¢ç›‘æ§å¾ªç¯è¢«å–æ¶ˆ")
                break
            except Exception as e:
                self.logger.error(f"âŒ ä½™é¢æ›´æ–°å¤±è´¥: {e}")
                await asyncio.sleep(self._balance_update_interval)

    async def _update_account_balance(self):
        """
        æ›´æ–°è´¦æˆ·ä½™é¢

        ä» Backpack collateral API è·å–USDCä½™é¢
        - spot_balance: availableQuantityï¼ˆç°è´§ä½™é¢ï¼Œæœªç”¨ä½œä¿è¯é‡‘ï¼‰
        - collateral_balance: lendQuantityï¼ˆæŠµæŠ¼å“ä½™é¢ï¼Œç”¨ä½œä¿è¯é‡‘ï¼‰
        - order_locked_balance: openOrderQuantityï¼ˆè®¢å•å†»ç»“ä½™é¢ï¼‰
        """
        try:
            # è°ƒç”¨äº¤æ˜“æ‰€APIè·å–æ‰€æœ‰ä½™é¢
            balances = await self.engine.exchange.get_balances()

            # æŸ¥æ‰¾USDCä½™é¢
            usdc_balance = None
            for balance in balances:
                if balance.currency.upper() == 'USDC':
                    usdc_balance = balance
                    break

            if usdc_balance:
                # ğŸ”¥ ä» raw_data ä¸­æå–è¯¦ç»†çš„ä½™é¢ä¿¡æ¯
                raw_data = usdc_balance.raw_data

                # availableQuantity = ç°è´§ä½™é¢ï¼ˆæœªç”¨ä½œä¿è¯é‡‘çš„ï¼‰
                self._spot_balance = self._safe_decimal(
                    raw_data.get('availableQuantity', '0'))

                # lendQuantity = æŠµæŠ¼å“ä½™é¢ï¼ˆç”¨ä½œä¿è¯é‡‘çš„ï¼‰
                self._collateral_balance = self._safe_decimal(
                    raw_data.get('lendQuantity', '0'))

                # openOrderQuantity = è®¢å•å†»ç»“ä½™é¢
                self._order_locked_balance = self._safe_decimal(
                    raw_data.get('openOrderQuantity', '0'))

                self._last_balance_update = datetime.now()

                # ğŸ›¡ï¸ å¦‚æœå¯ç”¨äº†æœ¬é‡‘ä¿æŠ¤ï¼Œè®°å½•åˆå§‹æœ¬é‡‘ï¼ˆé¦–æ¬¡è·å–ï¼‰
                if self.capital_protection_manager:
                    if self.capital_protection_manager.get_initial_capital() == Decimal('0'):
                        self.capital_protection_manager.initialize_capital(
                            self._collateral_balance)

                # ğŸ’° å¦‚æœå¯ç”¨äº†æ­¢ç›ˆæ¨¡å¼ï¼Œè®°å½•/æ›´æ–°åˆå§‹æœ¬é‡‘
                if self.take_profit_manager:
                    if self.take_profit_manager.get_initial_capital() == Decimal('0'):
                        # é¦–æ¬¡åˆå§‹åŒ–
                        self.take_profit_manager.initialize_capital(
                            self._collateral_balance, is_reinit=False)

                # ğŸ”´ å¦‚æœå¯ç”¨äº†å‰¥å¤´çš®ï¼Œè®°å½•åˆå§‹æœ¬é‡‘ï¼ˆé¦–æ¬¡è·å–ï¼‰
                if self.scalping_manager:
                    if self.scalping_manager.get_initial_capital() == Decimal('0'):
                        self.scalping_manager.initialize_capital(
                            self._collateral_balance)
                    else:
                        # å·²æœ‰æœ¬é‡‘ï¼Œæ£€æŸ¥æ˜¯å¦æ»¡è¶³æ­¢ç›ˆæ¡ä»¶
                        if self.take_profit_manager.check_take_profit_condition(self._collateral_balance):
                            # è§¦å‘æ­¢ç›ˆ
                            self.take_profit_manager.activate(
                                self._collateral_balance)
                            await self._execute_take_profit_reset()

                self.logger.info(
                    f"ğŸ’° ä½™é¢å·²æ›´æ–°: ç°è´§=${self._spot_balance:,.2f}, "
                    f"æŠµæŠ¼å“=${self._collateral_balance:,.2f}, "
                    f"è®¢å•å†»ç»“=${self._order_locked_balance:,.2f}"
                )
            else:
                all_currencies = [b.currency for b in balances]
                self.logger.warning(
                    f"âš ï¸ æœªæ‰¾åˆ°USDCä½™é¢ï¼Œæ‰€æœ‰å¸ç§: {', '.join(all_currencies) if all_currencies else '(ç©º)'}"
                )

        except Exception as e:
            self.logger.error(f"âŒ è·å–è´¦æˆ·ä½™é¢å¤±è´¥: {e}")
            import traceback
            self.logger.error(traceback.format_exc())

    def _safe_decimal(self, value, default='0') -> Decimal:
        """å®‰å…¨è½¬æ¢ä¸ºDecimal"""
        try:
            if value is None:
                return Decimal(default)
            return Decimal(str(value))
        except:
            return Decimal(default)
