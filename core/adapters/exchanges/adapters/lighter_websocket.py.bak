"""
Lighteräº¤æ˜“æ‰€é€‚é…å™¨ - WebSocketæ¨¡å—

å°è£…Lighter SDKçš„WebSocketåŠŸèƒ½ï¼Œæä¾›å®æ—¶æ•°æ®æµ
"""

from typing import Dict, Any, Optional, List, Callable
from decimal import Decimal
from datetime import datetime
import asyncio
import logging
import json

try:
    import lighter
    from lighter import WsClient
    LIGHTER_AVAILABLE = True
except ImportError:
    LIGHTER_AVAILABLE = False
    logging.warning("lighter SDKæœªå®‰è£…")

try:
    import websockets
    WEBSOCKETS_AVAILABLE = True
except ImportError:
    WEBSOCKETS_AVAILABLE = False
    logging.warning("websocketsåº“æœªå®‰è£…ï¼Œæ— æ³•ä½¿ç”¨ç›´æ¥è®¢é˜…åŠŸèƒ½")

from .lighter_base import LighterBase
from ..models import (
    TickerData, OrderBookData, TradeData, OrderData, PositionData,
    OrderBookLevel, OrderStatus, OrderSide, OrderType
)

logger = logging.getLogger(__name__)


class LighterWebSocket(LighterBase):
    """Lighter WebSocketå®¢æˆ·ç«¯"""

    def __init__(self, config: Dict[str, Any]):
        """
        åˆå§‹åŒ–Lighter WebSocketå®¢æˆ·ç«¯

        Args:
            config: é…ç½®å­—å…¸
        """
        if not LIGHTER_AVAILABLE:
            raise ImportError("lighter SDKæœªå®‰è£…ï¼Œæ— æ³•ä½¿ç”¨Lighter WebSocket")

        super().__init__(config)

        # WebSocketå®¢æˆ·ç«¯ï¼ˆSDKçš„WsClientï¼Œç”¨äºè®¢é˜…account_allï¼‰
        self.ws_client: Optional[WsClient] = None
        self._ws_task: Optional[asyncio.Task] = None

        # ç›´æ¥WebSocketè¿æ¥ï¼ˆç”¨äºè®¢é˜…account_all_ordersï¼‰
        self._direct_ws = None
        self._direct_ws_task: Optional[asyncio.Task] = None

        # ä¿å­˜äº‹ä»¶å¾ªç¯å¼•ç”¨
        self._event_loop: Optional[asyncio.AbstractEventLoop] = None

        # è®¢é˜…çš„å¸‚åœºå’Œè´¦æˆ·
        self._subscribed_markets: List[int] = []
        self._subscribed_accounts: List[int] = []

        # æ•°æ®ç¼“å­˜
        self._order_books: Dict[str, OrderBookData] = {}
        self._account_data: Dict[str, Any] = {}

        # å›è°ƒå‡½æ•°
        self._ticker_callbacks: List[Callable] = []
        self._orderbook_callbacks: List[Callable] = []
        self._trade_callbacks: List[Callable] = []
        self._order_callbacks: List[Callable] = []
        self._order_fill_callbacks: List[Callable] = []  # ğŸ”¥ æ–°å¢ï¼šè®¢å•æˆäº¤å›è°ƒ
        self._position_callbacks: List[Callable] = []

        # è¿æ¥çŠ¶æ€
        self._connected = False
        self._reconnect_attempts = 0
        self._max_reconnect_attempts = 10

        logger.info("Lighter WebSocketå®¢æˆ·ç«¯åˆå§‹åŒ–å®Œæˆ")

    # ============= è¿æ¥ç®¡ç† =============

    async def connect(self):
        """å»ºç«‹WebSocketè¿æ¥"""
        try:
            if self._connected:
                logger.warning("WebSocketå·²è¿æ¥")
                return

            # ğŸ”¥ ä¿å­˜äº‹ä»¶å¾ªç¯å¼•ç”¨ï¼ˆç”¨äºçº¿ç¨‹å®‰å…¨çš„å›è°ƒè°ƒåº¦ï¼‰
            self._event_loop = asyncio.get_event_loop()

            # æ³¨æ„ï¼šlighterçš„WsClientæ˜¯åŒæ­¥çš„ï¼Œéœ€è¦åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­è¿è¡Œ
            # è¿™é‡Œæˆ‘ä»¬å…ˆä¸å¯åŠ¨ï¼Œç­‰å¾…è®¢é˜…åå†å¯åŠ¨
            self._connected = True
            logger.info("Lighter WebSocketå‡†å¤‡å°±ç»ª")

        except Exception as e:
            logger.error(f"WebSocketè¿æ¥å¤±è´¥: {e}")
            raise

    async def disconnect(self):
        """æ–­å¼€WebSocketè¿æ¥"""
        try:
            self._connected = False

            # å…³é—­SDKçš„WebSocketä»»åŠ¡
            if self._ws_task and not self._ws_task.done():
                self._ws_task.cancel()
                try:
                    await self._ws_task
                except asyncio.CancelledError:
                    pass

            self.ws_client = None

            # å…³é—­ç›´æ¥WebSocketè¿æ¥
            if self._direct_ws_task and not self._direct_ws_task.done():
                self._direct_ws_task.cancel()
                try:
                    await self._direct_ws_task
                except asyncio.CancelledError:
                    pass

            if self._direct_ws:
                try:
                    await self._direct_ws.close()
                except:
                    pass
                self._direct_ws = None

            logger.info("âœ… WebSocketå·²æ–­å¼€ï¼ˆåŒ…æ‹¬ç›´æ¥è®¢é˜…ï¼‰")

        except Exception as e:
            logger.error(f"æ–­å¼€WebSocketæ—¶å‡ºé”™: {e}")

    async def reconnect(self):
        """é‡æ–°è¿æ¥WebSocket"""
        logger.info("å°è¯•é‡æ–°è¿æ¥WebSocket...")

        await self.disconnect()
        await asyncio.sleep(min(self._reconnect_attempts * 2, 30))

        try:
            await self.connect()
            await self._resubscribe_all()
            self._reconnect_attempts = 0
            logger.info("WebSocketé‡è¿æˆåŠŸ")
        except Exception as e:
            self._reconnect_attempts += 1
            logger.error(
                f"WebSocketé‡è¿å¤±è´¥ (å°è¯• {self._reconnect_attempts}/{self._max_reconnect_attempts}): {e}")

            if self._reconnect_attempts < self._max_reconnect_attempts:
                asyncio.create_task(self.reconnect())

    async def _resubscribe_all(self):
        """é‡æ–°è®¢é˜…æ‰€æœ‰é¢‘é“"""
        # é‡æ–°è®¢é˜…å¸‚åœºæ•°æ®
        for market_index in self._subscribed_markets.copy():
            await self.subscribe_orderbook(market_index)

        # é‡æ–°è®¢é˜…è´¦æˆ·æ•°æ®
        for account_index in self._subscribed_accounts.copy():
            await self.subscribe_account(account_index)

    # ============= è®¢é˜…ç®¡ç† =============

    async def subscribe_ticker(self, symbol: str, callback: Optional[Callable] = None):
        """
        è®¢é˜…tickeræ•°æ®

        Args:
            symbol: äº¤æ˜“å¯¹ç¬¦å·
            callback: æ•°æ®å›è°ƒå‡½æ•°
        """
        print(f"\n[WS-PRICE-DEBUG] ğŸ¯ å¼€å§‹è®¢é˜…ticker: symbol={symbol}")
        
        market_index = self.get_market_index(symbol)
        if market_index is None:
            logger.warning(f"æœªæ‰¾åˆ°äº¤æ˜“å¯¹ {symbol} çš„å¸‚åœºç´¢å¼•")
            return

        print(f"[WS-PRICE-DEBUG] ğŸ“‹ market_index={market_index}")

        if callback:
            self._ticker_callbacks.append(callback)
            print(f"[WS-PRICE-DEBUG] âœ… å·²æ³¨å†Œtickerå›è°ƒï¼Œå½“å‰å…±{len(self._ticker_callbacks)}ä¸ªå›è°ƒ")

        await self.subscribe_orderbook(market_index, symbol)
        print(f"[WS-PRICE-DEBUG] âœ… subscribe_orderbookå®Œæˆ")

    async def subscribe_orderbook(self, market_index_or_symbol, symbol: Optional[str] = None):
        """
        è®¢é˜…è®¢å•ç°¿

        Args:
            market_index_or_symbol: å¸‚åœºç´¢å¼•æˆ–äº¤æ˜“å¯¹ç¬¦å·
            symbol: äº¤æ˜“å¯¹ç¬¦å·ï¼ˆå¦‚æœç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¸‚åœºç´¢å¼•ï¼‰
        """
        logger.info(
            f"[WS-PRICE-DEBUG] ğŸ“š subscribe_orderbookè¢«è°ƒç”¨: market_index_or_symbol={market_index_or_symbol}, symbol={symbol}")

        if isinstance(market_index_or_symbol, str):
            symbol = market_index_or_symbol
            market_index = self.get_market_index(symbol)
            if market_index is None:
                logger.warning(f"æœªæ‰¾åˆ°äº¤æ˜“å¯¹ {symbol} çš„å¸‚åœºç´¢å¼•")
                return
        else:
            market_index = market_index_or_symbol
            if symbol is None:
                symbol = self._get_symbol_from_market_index(market_index)

        logger.info(
            f"[WS-PRICE-DEBUG] ğŸ“Š market_index={market_index}, symbol={symbol}")
        logger.info(
            f"[WS-PRICE-DEBUG] ğŸ“‹ å½“å‰_subscribed_markets={self._subscribed_markets}")

        if market_index not in self._subscribed_markets:
            self._subscribed_markets.append(market_index)
            logger.info(f"å·²è®¢é˜…è®¢å•ç°¿: {symbol} (market_index={market_index})")
            logger.info(
                f"[WS-PRICE-DEBUG] âœ… å·²æ·»åŠ åˆ°_subscribed_marketsï¼Œç°åœ¨={self._subscribed_markets}")

            # å¦‚æœWsClientå·²åˆ›å»ºï¼Œéœ€è¦é‡æ–°åˆ›å»ºä»¥åŒ…å«æ–°çš„è®¢é˜…
            logger.info(f"[WS-PRICE-DEBUG] ğŸ”„ å‡†å¤‡è°ƒç”¨_recreate_ws_client")
            await self._recreate_ws_client()
        else:
            logger.info(
                f"[WS-PRICE-DEBUG] âš ï¸ market_index={market_index}å·²åœ¨è®¢é˜…åˆ—è¡¨ä¸­ï¼Œè·³è¿‡")

    async def subscribe_trades(self, symbol: str, callback: Optional[Callable] = None):
        """
        è®¢é˜…æˆäº¤æ•°æ®

        Args:
            symbol: äº¤æ˜“å¯¹ç¬¦å·
            callback: æ•°æ®å›è°ƒå‡½æ•°
        """
        if callback:
            self._trade_callbacks.append(callback)

        # Lighterçš„è®¢å•ç°¿æ›´æ–°ä¸­åŒ…å«æˆäº¤ä¿¡æ¯
        await self.subscribe_orderbook(symbol)

    async def subscribe_account(self, account_index: Optional[int] = None):
        """
        è®¢é˜…è´¦æˆ·æ•°æ®

        Args:
            account_index: è´¦æˆ·ç´¢å¼•ï¼ˆé»˜è®¤ä½¿ç”¨é…ç½®ä¸­çš„è´¦æˆ·ï¼‰
        """
        if account_index is None:
            account_index = self.account_index

        if account_index not in self._subscribed_accounts:
            self._subscribed_accounts.append(account_index)
            logger.info(f"å·²è®¢é˜…è´¦æˆ·æ•°æ®: account_index={account_index}")

            # å¦‚æœWsClientå·²åˆ›å»ºï¼Œéœ€è¦é‡æ–°åˆ›å»ºä»¥åŒ…å«æ–°çš„è®¢é˜…
            await self._recreate_ws_client()

    async def subscribe_orders(self, callback: Optional[Callable] = None):
        """
        è®¢é˜…è®¢å•æ›´æ–°

        ä½¿ç”¨ç›´æ¥WebSocketè¿æ¥è®¢é˜…account_all_ordersé¢‘é“
        è¿™æ ·å¯ä»¥æ¥æ”¶æŒ‚å•çŠ¶æ€æ¨é€ï¼Œè€Œä¸ä»…ä»…æ˜¯æˆäº¤æ¨é€

        Args:
            callback: æ•°æ®å›è°ƒå‡½æ•°
        """
        if callback:
            self._order_callbacks.append(callback)

        # ğŸ”¥ å¯åŠ¨ç›´æ¥è®¢é˜…account_all_ordersï¼ˆåŒ…å«æŒ‚å•çŠ¶æ€ï¼‰
        await self._subscribe_account_all_orders()

        # ğŸ”¥ åŒæ—¶ä¿æŒaccount_allè®¢é˜…ï¼ˆç”¨äºæˆäº¤æ¨é€ï¼‰
        await self.subscribe_account()

    async def subscribe_order_fills(self, callback: Callable) -> None:
        """
        è®¢é˜…è®¢å•æˆäº¤ï¼ˆä¸“é—¨ç›‘æ§FILLEDçŠ¶æ€çš„è®¢å•ï¼‰

        Args:
            callback: è®¢å•æˆäº¤å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸ºOrderData
        """
        if callback:
            self._order_fill_callbacks.append(callback)

        await self.subscribe_account()

    async def subscribe_positions(self, callback: Optional[Callable] = None):
        """
        è®¢é˜…æŒä»“æ›´æ–°

        Args:
            callback: æ•°æ®å›è°ƒå‡½æ•°
        """
        if callback:
            self._position_callbacks.append(callback)

        await self.subscribe_account()

    async def unsubscribe_ticker(self, symbol: str):
        """å–æ¶ˆè®¢é˜…ticker"""
        market_index = self.get_market_index(symbol)
        if market_index and market_index in self._subscribed_markets:
            self._subscribed_markets.remove(market_index)
            await self._recreate_ws_client()

    async def unsubscribe_orderbook(self, symbol: str):
        """å–æ¶ˆè®¢é˜…è®¢å•ç°¿"""
        await self.unsubscribe_ticker(symbol)

    async def unsubscribe_trades(self, symbol: str):
        """å–æ¶ˆè®¢é˜…æˆäº¤"""
        await self.unsubscribe_ticker(symbol)

    # ============= WebSocketå®¢æˆ·ç«¯ç®¡ç† =============

    async def _recreate_ws_client(self):
        """é‡æ–°åˆ›å»ºWebSocketå®¢æˆ·ç«¯ï¼ˆå½“è®¢é˜…å˜åŒ–æ—¶ï¼‰"""
        logger.info(f"[WS-PRICE-DEBUG] ğŸ”§ _recreate_ws_clientè¢«è°ƒç”¨")
        logger.info(
            f"[WS-PRICE-DEBUG] ğŸ“‹ _subscribed_markets={self._subscribed_markets}")
        logger.info(
            f"[WS-PRICE-DEBUG] ğŸ“‹ _subscribed_accounts={self._subscribed_accounts}")

        if not self._subscribed_markets and not self._subscribed_accounts:
            logger.info("æ²¡æœ‰è®¢é˜…ï¼Œè·³è¿‡åˆ›å»ºWsClient")
            return

        try:
            # å…ˆå…³é—­æ—§çš„å®¢æˆ·ç«¯
            if self._ws_task and not self._ws_task.done():
                logger.info(f"[WS-PRICE-DEBUG] ğŸ›‘ å–æ¶ˆæ—§çš„WebSocketä»»åŠ¡")
                self._ws_task.cancel()
                try:
                    await self._ws_task
                except asyncio.CancelledError:
                    pass

            # åˆ›å»ºæ–°çš„WsClient
            # ğŸ”¥ ä»ws_urlä¸­æå–hostï¼ˆå»æ‰åè®®å’Œè·¯å¾„ï¼‰
            if not self.ws_url:
                logger.error("âŒ WebSocket URLæœªé…ç½®ï¼Œæ— æ³•åˆ›å»ºWebSocketå®¢æˆ·ç«¯")
                return

            ws_host = self.ws_url.replace("wss://", "").replace("ws://", "")
            # å¦‚æœURLä¸­åŒ…å«è·¯å¾„ï¼Œå»æ‰è·¯å¾„ï¼ˆSDKä¼šè‡ªåŠ¨æ·»åŠ /streamï¼‰
            if "/" in ws_host:
                ws_host = ws_host.split("/")[0]

            logger.info(f"[WS-PRICE-DEBUG] ğŸŒ ws_host={ws_host}")
            logger.info(
                f"[WS-PRICE-DEBUG] ğŸ“š å‡†å¤‡åˆ›å»ºWsClient: order_book_ids={self._subscribed_markets}")

            self.ws_client = WsClient(
                host=ws_host,
                path="/stream",  # æ˜ç¡®æŒ‡å®špath
                order_book_ids=self._subscribed_markets,
                account_ids=self._subscribed_accounts,
                on_order_book_update=self._on_order_book_update,
                on_account_update=self._on_account_update,
            )

            logger.info(
                f"[WS-PRICE-DEBUG] âœ… WsClientåˆ›å»ºæˆåŠŸï¼Œå›è°ƒå·²æ³¨å†Œï¼šon_order_book_update={self._on_order_book_update.__name__}")

            # åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­è¿è¡Œï¼ˆå› ä¸ºlighterçš„WsClientæ˜¯åŒæ­¥çš„ï¼‰
            self._ws_task = asyncio.create_task(self._run_ws_client())
            logger.info(f"[WS-PRICE-DEBUG] ğŸš€ WebSocketä»»åŠ¡å·²å¯åŠ¨")

            logger.info(
                f"âœ… WebSocketå·²è¿æ¥ - account: {self._subscribed_accounts[0] if self._subscribed_accounts else 'N/A'}")

        except Exception as e:
            logger.error(f"åˆ›å»ºWebSocketå®¢æˆ·ç«¯å¤±è´¥: {e}")

    async def _run_ws_client(self):
        """åœ¨å¼‚æ­¥ä»»åŠ¡ä¸­è¿è¡ŒåŒæ­¥çš„WsClient"""
        try:
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, self.ws_client.run)
            logger.warning("âš ï¸ WebSocketå®¢æˆ·ç«¯run()æ–¹æ³•é€€å‡ºäº†")
        except asyncio.CancelledError:
            logger.info("WebSocketä»»åŠ¡å·²å–æ¶ˆ")
        except Exception as e:
            logger.error(f"âŒ WebSocketè¿è¡Œå‡ºé”™: {e}", exc_info=True)
            # å°è¯•é‡è¿
            asyncio.create_task(self.reconnect())

    # ============= æ¶ˆæ¯å¤„ç† =============

    def _on_order_book_update(self, market_id: str, order_book: Dict[str, Any]):
        """
        è®¢å•ç°¿æ›´æ–°å›è°ƒ

        Args:
            market_id: å¸‚åœºID
            order_book: è®¢å•ç°¿æ•°æ®
        """
        try:
            logger.debug(f"[WS-PRICE-DEBUG] ğŸ“Š æ”¶åˆ°è®¢å•ç°¿æ›´æ–°: market_id={market_id}")

            market_index = int(market_id)
            symbol = self._get_symbol_from_market_index(market_index)

            if not symbol:
                logger.warning(f"æœªæ‰¾åˆ°market_index={market_index}å¯¹åº”çš„ç¬¦å·")
                return

            # è§£æè®¢å•ç°¿
            order_book_data = self._parse_order_book(symbol, order_book)
            logger.debug(
                f"[WS-PRICE-DEBUG] ğŸ“– è®¢å•ç°¿è§£æå®Œæˆ: bids={len(order_book_data.bids)}, asks={len(order_book_data.asks)}")
            if order_book_data.bids:
                logger.debug(
                    f"[WS-PRICE-DEBUG] ğŸ’° æœ€ä¼˜ä¹°ä»·={order_book_data.bids[0].price}")
            if order_book_data.asks:
                logger.debug(
                    f"[WS-PRICE-DEBUG] ğŸ’° æœ€ä¼˜å–ä»·={order_book_data.asks[0].price}")

            # ç¼“å­˜
            self._order_books[symbol] = order_book_data

            # è§¦å‘å›è°ƒ
            self._trigger_orderbook_callbacks(order_book_data)

            # ä»è®¢å•ç°¿ä¸­æå–tickeræ•°æ®
            if self._ticker_callbacks:
                logger.debug(
                    f"[WS-PRICE-DEBUG] ğŸ¯ å¼€å§‹æå–tickeræ•°æ®ï¼ˆæœ‰{len(self._ticker_callbacks)}ä¸ªå›è°ƒï¼‰")
                ticker = self._extract_ticker_from_orderbook(
                    symbol, order_book, order_book_data)
                if ticker:
                    logger.info(
                        f"[WS-PRICE-DEBUG] âœ… æå–tickeræˆåŠŸ: last={ticker.last}, bid={ticker.bid}, ask={ticker.ask}")
                    self._trigger_ticker_callbacks(ticker)
                else:
                    logger.warning(f"[WS-PRICE-DEBUG] âŒ æå–tickerå¤±è´¥ï¼ˆè¿”å›Noneï¼‰")
            else:
                logger.warning(f"[WS-PRICE-DEBUG] âš ï¸ æ²¡æœ‰tickerå›è°ƒæ³¨å†Œ")

        except Exception as e:
            logger.error(f"å¤„ç†è®¢å•ç°¿æ›´æ–°å¤±è´¥: {e}")

    def _on_account_update(self, account_id: str, account: Dict[str, Any]):
        """
        è´¦æˆ·æ•°æ®æ›´æ–°å›è°ƒ

        æ ¹æ®Lighter WebSocketæ–‡æ¡£ï¼Œaccountæ•°æ®åŒ…å«:
        - orders: {market_index: [Order]} - è®¢å•åˆ—è¡¨
        - trades: {market_index: [Trade]} - æˆäº¤åˆ—è¡¨
        - positions: {market_index: Position} - æŒä»“æ•°æ®

        Args:
            account_id: è´¦æˆ·ID
            account: è´¦æˆ·æ•°æ®
        """
        try:
            # ğŸ”¥ è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰WebSocketæ¨é€
            logger.info("=" * 70)
            logger.info(f"ğŸ”” æ”¶åˆ°WebSocketè´¦æˆ·æ›´æ–°æ¨é€ï¼")
            logger.info(f"   è´¦æˆ·ID: {account_id}")
            logger.info(f"   æ•°æ®keys: {list(account.keys())}")
            logger.info(f"   åŸå§‹æ•°æ®: {account}")
            logger.info("=" * 70)

            # ç¼“å­˜è´¦æˆ·æ•°æ®
            self._account_data[account_id] = account

            logger.debug(
                f"ğŸ“¥ æ”¶åˆ°è´¦æˆ·æ›´æ–°: account_id={account_id}, keys={list(account.keys())}")

            # ğŸ”¥ è§£æè®¢å•æ•°æ®ï¼ˆæ ¹æ®Lighter WebSocketæ–‡æ¡£ï¼‰
            if "orders" in account and account["orders"]:
                orders_data = account["orders"]

                # ordersæ˜¯å­—å…¸: {market_index: [Order]}
                if isinstance(orders_data, dict):
                    for market_index, order_list in orders_data.items():
                        if isinstance(order_list, list):
                            logger.info(
                                f"ğŸ“Š å¸‚åœº{market_index}æ”¶åˆ°{len(order_list)}ä¸ªè®¢å•æ›´æ–°")
                            for order_info in order_list:
                                # ğŸ”¥ è°ƒè¯•ï¼šæ‰“å°å®é™…æ”¶åˆ°çš„è®¢å•æ•°æ®
                                logger.info(
                                    f"ğŸ” æ”¶åˆ°è®¢å•æ•°æ®keys: {list(order_info.keys())}")
                                logger.debug(f"ğŸ” è®¢å•å®Œæ•´æ•°æ®: {order_info}")

                                order = self._parse_order_from_ws(order_info)
                                if order:
                                    logger.info(
                                        f"ğŸ“ è®¢å•æ›´æ–°: id={order.id}, "
                                        f"çŠ¶æ€={order.status}, ä»·æ ¼={order.price}, "
                                        f"æ•°é‡={order.amount}, å·²æˆäº¤={order.filled}")

                                    # è§¦å‘é€šç”¨è®¢å•å›è°ƒ
                                    if self._order_callbacks:
                                        self._trigger_order_callbacks(order)

                                    # å¦‚æœæ˜¯FILLEDçŠ¶æ€ï¼Œè§¦å‘è®¢å•æˆäº¤å›è°ƒ
                                    if self._order_fill_callbacks and order.status == OrderStatus.FILLED:
                                        logger.info(
                                            f"âœ… è®¢å•æˆäº¤: id={order.id}, "
                                            f"æˆäº¤ä»·={order.average}, æˆäº¤é‡={order.filled}")
                                        self._trigger_order_fill_callbacks(
                                            order)

            # ğŸ”¥ è§£ææˆäº¤æ•°æ®ï¼ˆTradeåˆ—è¡¨ï¼ŒLighteré€šè¿‡è¿™ä¸ªæ¨é€è®¢å•æˆäº¤ï¼‰
            if "trades" in account and account["trades"]:
                trades_data = account["trades"]
                if isinstance(trades_data, dict):
                    for market_index, trade_list in trades_data.items():
                        if isinstance(trade_list, list):
                            logger.info(
                                f"ğŸ“Š å¸‚åœº{market_index}æ”¶åˆ°{len(trade_list)}ä¸ªæˆäº¤è®°å½•")

                            # ğŸ”¥ éå†æ¯ä¸ªtradeï¼Œè§£æä¸ºOrderDataå¹¶è§¦å‘å›è°ƒ
                            for trade_info in trade_list:
                                logger.info(
                                    f"ğŸ” æ”¶åˆ°æˆäº¤æ•°æ®keys: {list(trade_info.keys())}")
                                logger.debug(f"ğŸ” æˆäº¤å®Œæ•´æ•°æ®: {trade_info}")

                                # è§£ætradeä¸ºOrderData
                                order = self._parse_trade_as_order(trade_info)
                                if order:
                                    logger.info(
                                        f"ğŸ’° è®¢å•æˆäº¤: id={order.id}, "
                                        f"ä»·æ ¼={order.average}, æ•°é‡={order.filled}, "
                                        f"æ–¹å‘={order.side.value}")

                                    # è§¦å‘è®¢å•å›è°ƒ
                                    if self._order_callbacks:
                                        self._trigger_order_callbacks(order)

                                    # è§¦å‘è®¢å•æˆäº¤å›è°ƒ
                                    if self._order_fill_callbacks:
                                        self._trigger_order_fill_callbacks(
                                            order)

            # è§£ææŒä»“æ›´æ–°
            if "positions" in account and self._position_callbacks:
                positions = self._parse_positions(account["positions"])
                for position in positions:
                    self._trigger_position_callbacks(position)

        except Exception as e:
            logger.error(f"âŒ å¤„ç†è´¦æˆ·æ›´æ–°å¤±è´¥: {e}", exc_info=True)

    # ============= æ•°æ®è§£æ =============

    def _parse_order_book(self, symbol: str, order_book: Dict[str, Any]) -> OrderBookData:
        """è§£æè®¢å•ç°¿æ•°æ®"""
        bids = []
        asks = []

        if "bids" in order_book:
            for bid in order_book["bids"]:
                # Lighter WebSocketè¿”å›å­—å…¸æ ¼å¼ï¼š{'price': '...', 'size': '...'}
                if isinstance(bid, dict):
                    bids.append(OrderBookLevel(
                        price=self._safe_decimal(bid.get('price', 0)),
                        size=self._safe_decimal(bid.get('size', 0))
                    ))
                # å…¼å®¹åˆ—è¡¨/å…ƒç»„æ ¼å¼ï¼š['price', 'size']
                elif isinstance(bid, (list, tuple)) and len(bid) >= 2:
                    bids.append(OrderBookLevel(
                        price=self._safe_decimal(bid[0]),
                        size=self._safe_decimal(bid[1])
                    ))

        if "asks" in order_book:
            for ask in order_book["asks"]:
                # Lighter WebSocketè¿”å›å­—å…¸æ ¼å¼ï¼š{'price': '...', 'size': '...'}
                if isinstance(ask, dict):
                    asks.append(OrderBookLevel(
                        price=self._safe_decimal(ask.get('price', 0)),
                        size=self._safe_decimal(ask.get('size', 0))
                    ))
                # å…¼å®¹åˆ—è¡¨/å…ƒç»„æ ¼å¼ï¼š['price', 'size']
                elif isinstance(ask, (list, tuple)) and len(ask) >= 2:
                    asks.append(OrderBookLevel(
                        price=self._safe_decimal(ask[0]),
                        size=self._safe_decimal(ask[1])
                    ))

        return OrderBookData(
            symbol=symbol,
            bids=bids,
            asks=asks,
            timestamp=datetime.now(),
            nonce=None
        )

    def _extract_ticker_from_orderbook(self, symbol: str, raw_data: Dict[str, Any], order_book: OrderBookData) -> Optional[TickerData]:
        """ä»è®¢å•ç°¿ä¸­æå–tickeræ•°æ®"""
        try:
            best_bid = order_book.bids[0].price if order_book.bids else Decimal(
                "0")
            best_ask = order_book.asks[0].price if order_book.asks else Decimal(
                "0")

            # æœ€æ–°ä»·æ ¼å–ä¸­é—´ä»·
            last_price = (best_bid + best_ask) / \
                2 if best_bid > 0 and best_ask > 0 else best_bid or best_ask

            return TickerData(
                symbol=symbol,
                timestamp=datetime.now(),
                bid=best_bid,
                ask=best_ask,
                last=last_price,
                volume=self._safe_decimal(raw_data.get("volume_24h", 0)),
                high=self._safe_decimal(
                    raw_data.get("high_24h", last_price)),
                low=self._safe_decimal(
                    raw_data.get("low_24h", last_price))
            )
        except Exception as e:
            logger.error(f"æå–tickeræ•°æ®å¤±è´¥: {e}")
            return None

    def _parse_orders(self, orders_data: Dict[str, Any]) -> List[OrderData]:
        """è§£æè®¢å•åˆ—è¡¨"""
        orders = []
        for market_index_str, order_list in orders_data.items():
            try:
                market_index = int(market_index_str)
                symbol = self._get_symbol_from_market_index(market_index)

                for order_info in order_list:
                    orders.append(self._parse_order(order_info, symbol))
            except Exception as e:
                logger.error(f"è§£æè®¢å•å¤±è´¥: {e}")

        return orders

    def _parse_order_from_ws(self, order_info: Dict[str, Any]) -> Optional[OrderData]:
        """
        è§£æWebSocketæ¨é€çš„Order JSON

        âš ï¸ æ ¹æ®Lighterå®˜æ–¹Goç»“æ„æ–‡æ¡£ï¼Œå®é™…å­—æ®µåæ˜¯ç¼©å†™å½¢å¼ï¼š
        - "i":  OrderIndex (int64) - è®¢å•ID
        - "u":  ClientOrderIndex (int64) - å®¢æˆ·ç«¯è®¢å•ID  
        - "is": InitialBaseAmount (int64) - åˆå§‹æ•°é‡ï¼ˆå•ä½1e5ï¼‰
        - "rs": RemainingBaseAmount (int64) - å‰©ä½™æ•°é‡ï¼ˆå•ä½1e5ï¼‰
        - "p":  Price (uint32) - ä»·æ ¼ï¼ˆéœ€è¦é™¤ä»¥price_multiplierï¼‰
        - "ia": IsAsk (uint8) - æ˜¯å¦å–å• (0=buy, 1=sell)
        - "st": Status (uint8) - çŠ¶æ€ç  (0=Failed, 1=Pending, 2=Executed, 3=Pending-Final)
        """
        try:
            from ..models import OrderSide, OrderType, OrderStatus

            # ğŸ”¥ ä½¿ç”¨å®é™…çš„ç¼©å†™å­—æ®µå
            order_index = order_info.get("i")  # OrderIndex
            client_order_index = order_info.get("u")  # ClientOrderIndex

            if order_index is None:
                logger.warning(
                    f"âš ï¸ è®¢å•æ•°æ®ç¼ºå°‘OrderIndex(i): keys={list(order_info.keys())}")
                return None

            order_id = str(order_index)

            # è·å–å¸‚åœºç´¢å¼•å’Œç¬¦å·ï¼ˆå‡è®¾å­—æ®µåæ˜¯"m"ï¼‰
            # TODO: éœ€è¦ç¡®è®¤market_indexçš„å®é™…å­—æ®µå
            market_index = order_info.get("m")
            symbol = self._get_symbol_from_market_index(
                market_index) if market_index else "UNKNOWN"

            # ğŸ”¥ è§£ææ•°é‡ï¼ˆä½¿ç”¨ç¼©å†™å­—æ®µï¼Œæ•°é‡å•ä½æ˜¯1e5ï¼‰
            initial_amount_raw = order_info.get("is", 0)  # InitialBaseAmount
            remaining_amount_raw = order_info.get(
                "rs", 0)  # RemainingBaseAmount

            initial_amount = self._safe_decimal(
                initial_amount_raw) / Decimal("100000")
            remaining_amount = self._safe_decimal(
                remaining_amount_raw) / Decimal("100000")
            filled_amount = initial_amount - remaining_amount

            # æš‚æ—¶æ— æ³•ä»Orderç»“æ„ç›´æ¥è·å–filled_quoteï¼Œè®¾ç½®ä¸º0
            filled_quote = Decimal("0")

            # è®¡ç®—æˆäº¤å‡ä»·ï¼ˆå¦‚æœæœ‰æˆäº¤ä¸”æœ‰ä»·æ ¼ï¼‰
            average_price = None
            price_raw = order_info.get("p", 0)  # Price (uint32)
            # æ ¹æ®å¸‚åœºçš„price_multiplierè°ƒæ•´ï¼Œè¿™é‡Œå‡è®¾æ˜¯10
            price = self._safe_decimal(price_raw) / Decimal("10")
            if filled_amount > 0 and price > 0:
                average_price = price  # è¿‘ä¼¼ä½¿ç”¨è®¢å•ä»·æ ¼

            # ğŸ”¥ è§£æè®¢å•æ–¹å‘ï¼ˆä½¿ç”¨ç¼©å†™å­—æ®µï¼‰
            is_ask = order_info.get("ia", 0)  # IsAsk (uint8: 0=buy, 1=sell)
            side = OrderSide.SELL if is_ask else OrderSide.BUY

            # ğŸ”¥ è§£æè®¢å•çŠ¶æ€ï¼ˆä½¿ç”¨ç¼©å†™å­—æ®µï¼ŒçŠ¶æ€æ˜¯æ•°å­—ï¼‰
            status_code = order_info.get("st", 1)  # Status (uint8)
            if status_code == 2:  # Executed
                status = OrderStatus.FILLED
            elif status_code == 0:  # Failed
                status = OrderStatus.CANCELED
            elif status_code == 1 or status_code == 3:  # Pending / Pending-Final
                status = OrderStatus.OPEN
            else:
                status = OrderStatus.PENDING

            # æ„é€ OrderData
            return OrderData(
                id=order_id,                                    # âœ… OrderIndexçš„å­—ç¬¦ä¸²å½¢å¼
                client_id=str(
                    client_order_index) if client_order_index else "",
                symbol=symbol,
                side=side,
                type=OrderType.LIMIT,
                amount=initial_amount,
                filled=filled_amount,
                remaining=remaining_amount,
                price=price,
                average=average_price,
                cost=filled_quote,
                status=status,
                timestamp=datetime.now(),
                updated=None,
                fee=None,
                trades=[],
                params={},
                raw_data=order_info
            )

        except Exception as e:
            logger.error(f"è§£æWebSocketè®¢å•å¤±è´¥: {e}", exc_info=True)
            return None

    def _parse_order(self, order_info: Dict[str, Any], symbol: str) -> OrderData:
        """è§£æå•ä¸ªè®¢å•ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰"""
        # ğŸ”¥ ä½¿ç”¨æ–°çš„è§£ææ–¹æ³•
        result = self._parse_order_from_ws(order_info)
        if result:
            return result

        # é™çº§å¤„ç†
        # ğŸ”¥ è®¡ç®—æˆäº¤å‡ä»·ï¼šæ ¹æ®Lighter SDKæ•°æ®ç»“æ„
        filled_base = self._safe_decimal(
            order_info.get("filled_base_amount", 0))
        filled_quote = self._safe_decimal(
            order_info.get("filled_quote_amount", 0))

        # è®¡ç®—å¹³å‡æˆäº¤ä»· = æˆäº¤é‡‘é¢ / æˆäº¤æ•°é‡
        average_price = None
        if filled_base > 0 and filled_quote > 0:
            average_price = filled_quote / filled_base

        order_data = OrderData(
            order_id=str(order_info.get("order_index", "")),
            client_order_id=str(order_info.get("client_order_index", "")),
            symbol=symbol,
            side=self._parse_order_side(order_info.get("is_ask", False)),
            order_type=self._parse_order_type(order_info.get("type", 0)),
            quantity=self._safe_decimal(
                order_info.get("initial_base_amount", 0)),
            price=self._safe_decimal(order_info.get("price", 0)),
            filled_quantity=filled_base,
            status=self._parse_order_status(
                order_info.get("status", "unknown")),
            timestamp=self._parse_timestamp(order_info.get("timestamp")),
            exchange="lighter"
        )

        # ğŸ”¥ è®¾ç½®æˆäº¤å‡ä»·ï¼ˆå¦‚æœæœ‰ï¼‰
        if average_price:
            order_data.average = average_price

        return order_data

    def _parse_trade_as_order(self, trade_info: Dict[str, Any]) -> Optional[OrderData]:
        """
        å°†tradeæ•°æ®è§£æä¸ºOrderDataï¼ˆç”¨äºWebSocketè®¢å•æˆäº¤é€šçŸ¥ï¼‰

        Lighter WebSocketä¸­ï¼Œäº¤æ˜“æˆäº¤æ•°æ®åœ¨'trades'é”®ä¸­

        Trade JSONæ ¼å¼ï¼ˆæ ¹æ®æ–‡æ¡£ï¼‰:
        {
            "trade_id": INTEGER,
            "tx_hash": STRING,
            "market_id": INTEGER,
            "size": STRING,
            "price": STRING,
            "ask_id": INTEGER,        # å–å•è®¢å•ID
            "bid_id": INTEGER,        # ä¹°å•è®¢å•ID
            "ask_account_id": INTEGER, # å–æ–¹è´¦æˆ·ID
            "bid_account_id": INTEGER, # ä¹°æ–¹è´¦æˆ·ID
            "is_maker_ask": BOOLEAN   # makeræ˜¯å–æ–¹(true)è¿˜æ˜¯ä¹°æ–¹(false)
        }
        """
        try:
            # ğŸ”¥ è·å–å¸‚åœºID
            market_id = trade_info.get("market_id")
            if market_id is None:
                logger.warning(f"äº¤æ˜“æ•°æ®ç¼ºå°‘market_id: {trade_info}")
                return None

            symbol = self._get_symbol_from_market_index(market_id)

            # ğŸ”¥ åˆ¤æ–­å½“å‰è´¦æˆ·æ˜¯ä¹°æ–¹è¿˜æ˜¯å–æ–¹
            ask_account_id = trade_info.get("ask_account_id")
            bid_account_id = trade_info.get("bid_account_id")

            # æ ¹æ®è´¦æˆ·IDåˆ¤æ–­æ˜¯ä¹°è¿˜æ˜¯å–
            is_sell = (ask_account_id == self.account_index)
            is_buy = (bid_account_id == self.account_index)

            if not (is_sell or is_buy):
                # è¿™ä¸ªtradeä¸å±äºå½“å‰è´¦æˆ·
                return None

            # ğŸ”¥ è·å–æ­£ç¡®çš„è®¢å•IDï¼ˆask_idæˆ–bid_idï¼‰
            order_id = trade_info.get(
                "ask_id") if is_sell else trade_info.get("bid_id")
            if order_id is None:
                logger.warning(f"äº¤æ˜“æ•°æ®ç¼ºå°‘è®¢å•ID: {trade_info}")
                return None

            # è§£æäº¤æ˜“æ•°é‡å’Œä»·æ ¼
            size_str = trade_info.get("size", "0")
            price_str = trade_info.get("price", "0")
            usd_amount_str = trade_info.get("usd_amount", "0")

            base_amount = self._safe_decimal(size_str)
            trade_price = self._safe_decimal(price_str)
            usd_amount = self._safe_decimal(usd_amount_str)

            # ğŸ”¥ æ„é€ OrderData
            from ..models import OrderSide, OrderType, OrderStatus

            order_data = OrderData(
                id=str(order_id),  # âœ… ä½¿ç”¨ask_idæˆ–bid_idä½œä¸ºè®¢å•ID
                client_id="",
                symbol=symbol,
                side=OrderSide.SELL if is_sell else OrderSide.BUY,
                type=OrderType.LIMIT,  # Tradeå¯èƒ½æ¥è‡ªé™ä»·å•
                amount=base_amount,
                price=trade_price,
                filled=base_amount,  # äº¤æ˜“å…¨éƒ¨æˆäº¤
                remaining=Decimal("0"),  # å·²å…¨éƒ¨æˆäº¤
                cost=usd_amount,  # æˆäº¤é‡‘é¢
                average=trade_price,  # æˆäº¤ä»·
                status=OrderStatus.FILLED,  # å·²æˆäº¤
                timestamp=self._parse_timestamp(trade_info.get("timestamp")),
                updated=self._parse_timestamp(trade_info.get("timestamp")),
                fee=None,
                trades=[],
                params={},
                raw_data=trade_info
            )

            return order_data

        except Exception as e:
            logger.error(f"è§£æäº¤æ˜“æ•°æ®å¤±è´¥: {e}", exc_info=True)
            return None

    def _parse_positions(self, positions_data: Dict[str, Any]) -> List[PositionData]:
        """è§£ææŒä»“åˆ—è¡¨"""
        positions = []
        for market_index_str, position_info in positions_data.items():
            try:
                market_index = int(market_index_str)
                symbol = self._get_symbol_from_market_index(market_index)

                position_size = self._safe_decimal(
                    position_info.get("position", 0))
                if position_size == 0:
                    continue

                positions.append(PositionData(
                    symbol=symbol,
                    side="long" if position_size > 0 else "short",
                    size=abs(position_size),
                    entry_price=self._safe_decimal(
                        position_info.get("avg_entry_price", 0)),
                    unrealized_pnl=self._safe_decimal(
                        position_info.get("unrealized_pnl", 0)),
                    realized_pnl=self._safe_decimal(
                        position_info.get("realized_pnl", 0)),
                    liquidation_price=self._safe_decimal(
                        position_info.get("liquidation_price")),
                    leverage=Decimal("1"),
                    exchange="lighter"
                ))
            except Exception as e:
                logger.error(f"è§£ææŒä»“å¤±è´¥: {e}")

        return positions

    def _get_symbol_from_market_index(self, market_index: int) -> str:
        """ä»å¸‚åœºç´¢å¼•è·å–ç¬¦å·"""
        market_info = self._markets_cache.get(market_index)
        if market_info:
            return market_info.get("symbol", "")
        return f"MARKET_{market_index}"

    # ============= å›è°ƒè§¦å‘ =============

    def _trigger_ticker_callbacks(self, ticker: TickerData):
        """è§¦å‘tickerå›è°ƒï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        for callback in self._ticker_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    # ğŸ”¥ WebSocketåœ¨åŒæ­¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨åœ°è°ƒåº¦åç¨‹
                    if self._event_loop and self._event_loop.is_running():
                        asyncio.run_coroutine_threadsafe(
                            callback(ticker), self._event_loop)
                    else:
                        logger.debug("âš ï¸ äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œè·³è¿‡tickerå›è°ƒ")
                else:
                    callback(ticker)
            except Exception as e:
                logger.error(f"tickerå›è°ƒæ‰§è¡Œå¤±è´¥: {e}")

    def _trigger_orderbook_callbacks(self, orderbook: OrderBookData):
        """è§¦å‘è®¢å•ç°¿å›è°ƒï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        for callback in self._orderbook_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    # ğŸ”¥ WebSocketåœ¨åŒæ­¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨åœ°è°ƒåº¦åç¨‹
                    if self._event_loop and self._event_loop.is_running():
                        asyncio.run_coroutine_threadsafe(
                            callback(orderbook), self._event_loop)
                    else:
                        logger.debug("âš ï¸ äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œè·³è¿‡è®¢å•ç°¿å›è°ƒ")
                else:
                    callback(orderbook)
            except Exception as e:
                logger.error(f"è®¢å•ç°¿å›è°ƒæ‰§è¡Œå¤±è´¥: {e}")

    def _trigger_trade_callbacks(self, trade: TradeData):
        """è§¦å‘æˆäº¤å›è°ƒï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        for callback in self._trade_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    # ğŸ”¥ WebSocketåœ¨åŒæ­¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨åœ°è°ƒåº¦åç¨‹
                    if self._event_loop and self._event_loop.is_running():
                        asyncio.run_coroutine_threadsafe(
                            callback(trade), self._event_loop)
                    else:
                        logger.debug("âš ï¸ äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œè·³è¿‡æˆäº¤å›è°ƒ")
                else:
                    callback(trade)
            except Exception as e:
                logger.error(f"æˆäº¤å›è°ƒæ‰§è¡Œå¤±è´¥: {e}")

    def _trigger_order_callbacks(self, order: OrderData):
        """è§¦å‘è®¢å•å›è°ƒï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        for callback in self._order_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    # ğŸ”¥ WebSocketåœ¨åŒæ­¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨åœ°è°ƒåº¦åç¨‹
                    if self._event_loop and self._event_loop.is_running():
                        asyncio.run_coroutine_threadsafe(
                            callback(order), self._event_loop)
                    else:
                        logger.debug("âš ï¸ äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œè·³è¿‡è®¢å•å›è°ƒ")
                else:
                    callback(order)
            except Exception as e:
                logger.error(f"è®¢å•å›è°ƒæ‰§è¡Œå¤±è´¥: {e}")

    def _trigger_order_fill_callbacks(self, order: OrderData):
        """è§¦å‘è®¢å•æˆäº¤å›è°ƒï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        for callback in self._order_fill_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    # ğŸ”¥ WebSocketåœ¨åŒæ­¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨åœ°è°ƒåº¦åç¨‹
                    if self._event_loop and self._event_loop.is_running():
                        asyncio.run_coroutine_threadsafe(
                            callback(order), self._event_loop)
                    else:
                        logger.warning("âš ï¸ äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œæ— æ³•è°ƒåº¦å¼‚æ­¥å›è°ƒ")
                else:
                    callback(order)
            except Exception as e:
                logger.error(f"è®¢å•æˆäº¤å›è°ƒæ‰§è¡Œå¤±è´¥: {e}")

    def _trigger_position_callbacks(self, position: PositionData):
        """è§¦å‘æŒä»“å›è°ƒï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        for callback in self._position_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    # ğŸ”¥ WebSocketåœ¨åŒæ­¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨åœ°è°ƒåº¦åç¨‹
                    if self._event_loop and self._event_loop.is_running():
                        asyncio.run_coroutine_threadsafe(
                            callback(position), self._event_loop)
                    else:
                        logger.debug("âš ï¸ äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œè·³è¿‡æŒä»“å›è°ƒ")
                else:
                    callback(position)
            except Exception as e:
                logger.error(f"æŒä»“å›è°ƒæ‰§è¡Œå¤±è´¥: {e}")

    # ============= ç›´æ¥è®¢é˜…account_all_orders =============

    async def _subscribe_account_all_orders(self):
        """
        ç›´æ¥è®¢é˜…account_all_ordersé¢‘é“

        æ ¹æ®Lighter WebSocketæ–‡æ¡£ï¼Œè®¢é˜…account_all_orderséœ€è¦ï¼š
        1. å»ºç«‹WebSocketè¿æ¥åˆ° wss://mainnet.zklighter.elliot.ai/stream
        2. å‘é€è®¢é˜…æ¶ˆæ¯ï¼ŒåŒ…å«auth token
        3. æ¥æ”¶è®¢å•æ¨é€ï¼ˆåŒ…æ‹¬æŒ‚å•çŠ¶æ€ï¼‰
        """
        if not WEBSOCKETS_AVAILABLE:
            logger.warning("âš ï¸ websocketsåº“æœªå®‰è£…ï¼Œæ— æ³•ç›´æ¥è®¢é˜…è®¢å•")
            return

        if self._direct_ws_task and not self._direct_ws_task.done():
            logger.info("âš ï¸ ç›´æ¥è®¢é˜…ä»»åŠ¡å·²åœ¨è¿è¡Œ")
            return

        # å¯åŠ¨ç›´æ¥è®¢é˜…ä»»åŠ¡
        self._direct_ws_task = asyncio.create_task(
            self._run_direct_ws_subscription())
        logger.info("ğŸš€ å·²å¯åŠ¨ç›´æ¥è®¢é˜…account_all_ordersä»»åŠ¡")

    async def _run_direct_ws_subscription(self):
        """è¿è¡Œç›´æ¥WebSocketè®¢é˜…"""
        try:
            # æ£€æŸ¥SignerClientæ˜¯å¦å¯ç”¨
            if not self.signer_client:
                logger.error("âŒ SignerClientæœªåˆå§‹åŒ–ï¼Œæ— æ³•è®¢é˜…è®¢å•")
                return

            # ğŸ”¥ ç”Ÿæˆauth tokenï¼ˆæœ‰æ•ˆæœŸ1å°æ—¶ï¼‰
            # create_auth_token_with_expiryéœ€è¦è¿‡æœŸæ—¶é—´æˆ³ï¼ˆç§’çº§ï¼‰ï¼Œä¸æ˜¯ç›¸å¯¹ç§’æ•°
            import time
            expiry_timestamp = int(time.time()) + 3600  # å½“å‰æ—¶é—´+1å°æ—¶

            result = self.signer_client.create_auth_token_with_expiry(
                expiry_timestamp)
            # è¿”å›çš„æ˜¯å…ƒç»„ (token, None)
            auth_token = result[0] if isinstance(result, tuple) else result

            logger.info(f"âœ… ç”Ÿæˆè®¤è¯token (è¿‡æœŸæ—¶é—´: {expiry_timestamp})")

            # è¿æ¥WebSocket
            ws_url = self.ws_url
            logger.info(f"ğŸ”— è¿æ¥WebSocket: {ws_url}")

            async with websockets.connect(ws_url) as ws:
                self._direct_ws = ws

                # å‘é€è®¢é˜…æ¶ˆæ¯
                subscribe_msg = {
                    "type": "subscribe",
                    "channel": f"account_all_orders/{self.account_index}",
                    "auth": auth_token
                }
                await ws.send(json.dumps(subscribe_msg))
                logger.info(
                    f"âœ… å·²è®¢é˜…é¢‘é“: account_all_orders/{self.account_index}")

                # æŒç»­æ¥æ”¶æ¶ˆæ¯
                async for message in ws:
                    try:
                        data = json.loads(message)
                        await self._handle_direct_ws_message(data)
                    except json.JSONDecodeError as e:
                        logger.error(f"âŒ JSONè§£æå¤±è´¥: {e}")
                    except Exception as e:
                        logger.error(f"âŒ å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}", exc_info=True)

        except Exception as e:
            logger.error(f"âŒ ç›´æ¥WebSocketè®¢é˜…å¤±è´¥: {e}", exc_info=True)
            # 5ç§’åé‡è¿
            await asyncio.sleep(5)
            if not self._direct_ws_task or self._direct_ws_task.done():
                self._direct_ws_task = asyncio.create_task(
                    self._run_direct_ws_subscription())

    async def _handle_direct_ws_message(self, data: Dict[str, Any]):
        """
        å¤„ç†ç›´æ¥WebSocketæ¶ˆæ¯

        æ ¹æ®æ–‡æ¡£ï¼Œaccount_all_ordersè¿”å›ï¼š
        {
            "channel": "account_all_orders:{ACCOUNT_ID}",
            "orders": {
                "{MARKET_INDEX}": [Order]
            },
            "type": "update/account_all_orders"
        }
        """
        try:
            msg_type = data.get("type", "")
            channel = data.get("channel", "")

            logger.info("="*70)
            logger.info(f"ğŸ”” æ”¶åˆ°ç›´æ¥WebSocketæ¨é€ï¼")
            logger.info(f"   é¢‘é“: {channel}")
            logger.info(f"   ç±»å‹: {msg_type}")
            logger.info(f"   æ•°æ®keys: {list(data.keys())}")
            logger.info("="*70)

            # å¤„ç†è®¢å•æ›´æ–°
            if msg_type == "update/account_all_orders" and "orders" in data:
                orders_data = data["orders"]

                if isinstance(orders_data, dict):
                    for market_index, order_list in orders_data.items():
                        if isinstance(order_list, list):
                            logger.info(
                                f"ğŸ“Š å¸‚åœº{market_index}æ”¶åˆ°{len(order_list)}ä¸ªè®¢å•")

                            for order_info in order_list:
                                logger.info(
                                    f"ğŸ” è®¢å•æ•°æ®keys: {list(order_info.keys())}")
                                logger.debug(f"ğŸ” è®¢å•å®Œæ•´æ•°æ®: {order_info}")

                                # è§£æè®¢å•ï¼ˆä½¿ç”¨å®Œæ•´çš„Order JSONæ ¼å¼ï¼‰
                                order = self._parse_order_from_direct_ws(
                                    order_info)
                                if order:
                                    logger.info(
                                        f"ğŸ“ è®¢å•æ¨é€: id={order.id}, "
                                        f"çŠ¶æ€={order.status.value}, ä»·æ ¼={order.price}, "
                                        f"æ•°é‡={order.amount}, å·²æˆäº¤={order.filled}")

                                    # è§¦å‘è®¢å•å›è°ƒ
                                    if self._order_callbacks:
                                        for callback in self._order_callbacks:
                                            if asyncio.iscoroutinefunction(callback):
                                                await callback(order)
                                            else:
                                                callback(order)

                                    # å¦‚æœæ˜¯æˆäº¤çŠ¶æ€ï¼Œè§¦å‘æˆäº¤å›è°ƒ
                                    if order.status == OrderStatus.FILLED and self._order_fill_callbacks:
                                        for callback in self._order_fill_callbacks:
                                            if asyncio.iscoroutinefunction(callback):
                                                await callback(order)
                                            else:
                                                callback(order)

        except Exception as e:
            logger.error(f"âŒ å¤„ç†ç›´æ¥WebSocketæ¶ˆæ¯å¤±è´¥: {e}", exc_info=True)

    def _parse_order_from_direct_ws(self, order_info: Dict[str, Any]) -> Optional[OrderData]:
        """
        è§£ææ¥è‡ªaccount_all_ordersçš„è®¢å•æ•°æ®

        æ ¹æ®æ–‡æ¡£ï¼ŒOrder JSONæ ¼å¼ï¼š
        {
            "order_index": INTEGER,
            "client_order_index": INTEGER,
            "market_index": INTEGER,
            "initial_base_amount": STRING,
            "price": STRING,
            "remaining_base_amount": STRING,
            "filled_base_amount": STRING,
            "filled_quote_amount": STRING,
            "is_ask": BOOL,
            "status": STRING,  # "open", "filled", "canceled"
            ...
        }
        """
        try:
            # è·å–å¸‚åœºç¬¦å·
            market_index = order_info.get("market_index")
            if market_index is None:
                return None

            symbol = self._get_symbol_from_market_index(market_index)

            # è®¢å•ID
            order_index = order_info.get("order_index")
            order_id = str(order_index) if order_index is not None else ""

            # æ•°é‡å’Œä»·æ ¼
            initial_amount = self._safe_decimal(
                order_info.get("initial_base_amount", "0"))
            remaining_amount = self._safe_decimal(
                order_info.get("remaining_base_amount", "0"))
            filled_amount = self._safe_decimal(
                order_info.get("filled_base_amount", "0"))
            price = self._safe_decimal(order_info.get("price", "0"))

            # æˆäº¤é‡‘é¢å’Œå‡ä»·
            filled_quote = self._safe_decimal(
                order_info.get("filled_quote_amount", "0"))
            average_price = filled_quote / filled_amount if filled_amount > 0 else None

            # æ–¹å‘
            is_ask = order_info.get("is_ask", False)
            side = OrderSide.SELL if is_ask else OrderSide.BUY

            # çŠ¶æ€
            status_str = order_info.get("status", "unknown").lower()
            if status_str == "filled":
                status = OrderStatus.FILLED
            elif status_str == "canceled" or status_str == "cancelled":
                status = OrderStatus.CANCELED
            elif status_str == "open":
                status = OrderStatus.OPEN
            else:
                status = OrderStatus.OPEN  # é»˜è®¤ä¸ºOPEN

            # åˆ›å»ºOrderData
            return OrderData(
                id=order_id,
                client_id=str(order_info.get("client_order_index", "")),
                symbol=symbol,
                side=side,
                type=OrderType.LIMIT,
                amount=initial_amount,
                price=price,
                filled=filled_amount,
                remaining=remaining_amount,
                cost=filled_quote,
                average=average_price,
                status=status,
                timestamp=self._parse_timestamp(order_info.get("timestamp")),
                updated=None,
                fee=None,
                trades=[],
                params={},
                raw_data=order_info
            )

        except Exception as e:
            logger.error(f"è§£æè®¢å•å¤±è´¥: {e}", exc_info=True)
            return None

    def get_cached_orderbook(self, symbol: str) -> Optional[OrderBookData]:
        """è·å–ç¼“å­˜çš„è®¢å•ç°¿"""
        return self._order_books.get(symbol)
